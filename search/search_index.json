{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"deluge-card \u00b6 A Python3 api for Synthstrom Audible Deluge SD cards. Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT Features \u00b6 List sub-folders that resemble Deluge cards (DelugeCardFS). List contents of deluge filesystems (cards , folders). Get details of card contents: songs, samples, sample usage. Get song details like tempo , key , scale . Filter contents by paths, using posix ls glob patterns. Move samples like posix mv . Unit tested on Macosx, Linux & Windows, Python 3.8+. Song XML from fw3.15. Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#deluge-card","text":"A Python3 api for Synthstrom Audible Deluge SD cards. Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT","title":"deluge-card"},{"location":"#features","text":"List sub-folders that resemble Deluge cards (DelugeCardFS). List contents of deluge filesystems (cards , folders). Get details of card contents: songs, samples, sample usage. Get song details like tempo , key , scale . Filter contents by paths, using posix ls glob patterns. Move samples like posix mv . Unit tested on Macosx, Linux & Windows, Python 3.8+. Song XML from fw3.15.","title":"Features"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Package: deluge_card \u00b6 Top-level package for deluge-card. Module deluge_card \u00b6 Main class representing a Deluge Filesystem in a folder or a mounted SD card. DelugeCardFS \u00b6 Main class representing a Deluge SD card/folder structure. Attributes: Name Type Description card_root Path Path object for the root folder. Source code in deluge_card/deluge_card.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @define ( frozen = True ) class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure. Attributes: card_root (Path): Path object for the root folder. \"\"\" card_root : Path = field () @card_root . validator def _check_card_root ( self , attribute , value ): if not value . is_dir (): raise InvalidDelugeCard ( f ' { value } is not a directory path.' ) for folder in TOP_FOLDERS : if not Path ( value , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { value } ' ) @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) def samples ( self , pattern : str = \"\" ) -> Iterator [ 'Sample' ]: \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) from_folder ( folder ) staticmethod \u00b6 New instance from a Deluge Folder structure. Parameters: Name Type Description Default folder str valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 93 94 95 96 97 98 99 100 101 102 103 @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) initialise ( path ) staticmethod \u00b6 Create a new Deluge Folder structure. Parameters: Name Type Description Default path str a valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore is_mounted () \u00b6 Is this a mounted SD card. Returns: Name Type Description mounted bool True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 105 106 107 108 109 110 111 112 113 114 def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () samples ( pattern = '' ) \u00b6 Generator for samples in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def samples ( self , pattern : str = \"\" ) -> Iterator [ 'Sample' ]: \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) songs ( pattern = '' ) \u00b6 Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) InvalidDelugeCard \u00b6 Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 43 44 45 46 47 48 49 50 51 52 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str __init__ ( msg ) \u00b6 Create a new InvalidDelugeCard Exception. Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 46 47 48 49 50 51 52 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str list_deluge_fs ( folder ) \u00b6 List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Yields: Name Type Description cards Iterator [ DelugeCardFS ] generator of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def list_deluge_fs ( folder ) -> Iterator [ 'DelugeCardFS' ]: \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Yields: cards (Iterator[DelugeCardFS]): generator of DelugeCardFS instances. \"\"\" def _test_card_fs ( folder ): try : return DelugeCardFS . from_folder ( folder ) except InvalidDelugeCard : return card = _test_card_fs ( folder ) if card : yield card for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if not card : continue yield card Module: deluge_sample \u00b6 Main classes representing Deluge Sample. ModOp \u00b6 Bases: object Represents a successful modification operation. Attributes: Name Type Description operation str str path str file path instance Any modified instance. Source code in deluge_card/deluge_sample.py 156 157 158 159 160 161 162 163 164 165 166 167 168 @define class ModOp ( object ): \"\"\"Represents a successful modification operation. Attributes: operation: str path (str): file path instance (Any): modified instance. \"\"\" operation : str path : str instance : object Sample \u00b6 Bases: object represents a sample file. Attributes: Name Type Description path Path Path object for the sample file. settings list [ SampleSetting ] list of SampleSettings for this sample Source code in deluge_card/deluge_sample.py 129 130 131 132 133 134 135 136 137 138 139 @define # (eq=False) # frozen abuse! class Sample ( object ): \"\"\"represents a sample file. Attributes: path (Path): Path object for the sample file. settings (list[SampleSetting]): list of SampleSettings for this sample \"\"\" path : Path settings : List [ 'SampleSetting' ] = field ( factory = list , eq = False ) SampleMoveOperation \u00b6 Bases: object Represents a sample file move operation. Attributes: Name Type Description old_path Path original Path. new_path Path new Path. sample Sample sample instance. Source code in deluge_card/deluge_sample.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @define ( eq = False ) class SampleMoveOperation ( object ): \"\"\"Represents a sample file move operation. Attributes: old_path (Path): original Path. new_path (Path): new Path. sample (Sample): sample instance. \"\"\" old_path : Path new_path : Path sample : 'Sample' uniqid : int = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( self . old_path ) def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path ) do_move () \u00b6 Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. Source code in deluge_card/deluge_sample.py 118 119 120 121 122 123 124 125 126 def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path ) SampleSetting \u00b6 Bases: object represents a sample in the context of a DelugeSong. Attributes: Name Type Description song_path Path Path object for the XML song file. xml_path str Xmlpath string locating the sample setting within the XML. Source code in deluge_card/deluge_sample.py 142 143 144 145 146 147 148 149 150 151 152 153 @define class SampleSetting ( object ): \"\"\"represents a sample in the context of a DelugeSong. Attributes: song_path (Path): Path object for the XML song file. xml_path (str): Xmlpath string locating the sample setting within the XML. \"\"\" song : 'deluge_song.DelugeSong' # noqa (for F821 undefined name) sample : 'Sample' xml_path : str ensure_absolute ( root , dest ) \u00b6 Make sure the path is absolute, if not make it relate to the root folder. Source code in deluge_card/deluge_sample.py 50 51 52 def ensure_absolute ( root : Path , dest : Path ): \"\"\"Make sure the path is absolute, if not make it relate to the root folder.\"\"\" return dest if dest . is_absolute () else Path ( root , dest ) modify_sample_paths ( root , samples , pattern , dest ) \u00b6 Modify sample paths just as posix mv does. Source code in deluge_card/deluge_sample.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def modify_sample_paths ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ) -> Iterator [ 'SampleMoveOperation' ]: \"\"\"Modify sample paths just as posix mv does.\"\"\" def glob_match ( sample ) -> bool : return Path ( sample . path ) . match ( pattern ) def build_move_op ( sample ) -> SampleMoveOperation : # print('DEBUG:', sample.path) if dest . suffix == '' : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest , sample . path . name ), sample ) else : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest ), sample ) sample . path = move_op . new_path . relative_to ( root ) return move_op matching_samples = filter ( glob_match , samples ) return map ( build_move_op , matching_samples ) modify_sample_songs ( samples ) \u00b6 Update song XML elements. Source code in deluge_card/deluge_sample.py 36 37 38 39 40 41 42 43 44 45 46 47 def modify_sample_songs ( samples : Iterator [ 'Sample' ]) -> Iterator [ 'deluge_song.DelugeSong' ]: \"\"\"Update song XML elements.\"\"\" def update_song_elements ( sample ): # print(f\"DEBUG update_song_elements: {sample}\") for setting in sample . settings : # print(f\"DEBUG update_song_elements setting: {setting}\") elem = setting . song . update_sample_element ( setting ) assert elem . get ( 'fileName' ) == str ( setting . sample . path ) yield setting . song return itertools . chain . from_iterable ( map ( update_song_elements , samples )) mv_samples ( root , samples , pattern , dest ) \u00b6 Move samples, updating any affected songs. Source code in deluge_card/deluge_sample.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def mv_samples ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ): \"\"\"Move samples, updating any affected songs.\"\"\" # print('DEBUG', root, pattern, dest) dest = ensure_absolute ( root , dest ) validate_mv_dest ( root , dest ) # raises exception if args are invalid sample_move_ops = list ( modify_sample_paths ( root , samples , pattern , dest )) # do materialise the list updated_songs = modify_sample_songs ( map ( lambda mo : mo . sample , sample_move_ops )) # write the modified XML, per unique song for song in set ( updated_songs ): song . write_xml () yield ModOp ( \"update_song_xml\" , str ( song . path ), song ) # move the files, per unique sample for move_op in set ( sample_move_ops ): move_op . do_move () yield ModOp ( \"move_file\" , str ( move_op . new_path ), move_op ) validate_mv_dest ( root , dest ) \u00b6 Source code in deluge_card/deluge_sample.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def validate_mv_dest ( root : Path , dest : Path ): \"\"\"Check: dest path must be a child of root and must exist.\"\"\" absolute_dest = ensure_absolute ( root , dest ) # file as target if absolute_dest . suffix : # looks like a file target if not absolute_dest . parent . exists (): raise ValueError ( f \"target folder does not exist: { dest } \" ) # folder as target elif not ( absolute_dest . is_dir ()): raise ValueError ( f \"target folder does not exist: { dest } \" ) try : absolute_dest . parent . relative_to ( root ) except ValueError : raise ValueError ( \"Destination must be a sub-folder of card.\" ) Module: deluge_song \u00b6 Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js DelugeSong \u00b6 Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: Name Type Description path Path Path object for the sample file. file. Source code in deluge_card/deluge_song.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @define ( repr = False , frozen = True ) class DelugeSong : \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path xmlroot : etree . ElementTree = field () @xmlroot . default def _default_xlmroot ( self ): return etree . parse ( self . path ) . getroot () def __repr__ ( self ) -> str : return f \"DelugeSong( { self . path } )\" def update_sample_element ( self , sample_setting ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( sample_setting . xml_path . replace ( '/song/' , '//' )) # print('DEBUG old path', elem.get('fileName')) elem . set ( 'fileName' , str ( sample_setting . sample . path )) return elem def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) def sample_in_setting ( sample_file , tree ) -> Sample : sample = Sample ( Path ( sample_file )) sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) return sample for e in self . xmlroot . findall ( \".//*[@fileName]\" ): # print(f'elem {e}') sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree ) minimum_firmware () \u00b6 Get the songs earliest Compatible Firmware version. Returns: Name Type Description str str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 76 77 78 79 80 81 82 def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) mode_notes () \u00b6 Get the notes in the song scale (mode). Returns: Type Description List [ int ] [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 92 93 94 95 96 97 98 99 def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] root_note () \u00b6 Get the root note. Returns: Name Type Description int int root note (e.g 36 for C3). Source code in deluge_card/deluge_song.py 84 85 86 87 88 89 90 def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) samples ( pattern = '' ) \u00b6 Generator for samples referenced in the DelugeSong. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_song.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) def sample_in_setting ( sample_file , tree ) -> Sample : sample = Sample ( Path ( sample_file )) sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) return sample for e in self . xmlroot . findall ( \".//*[@fileName]\" ): # print(f'elem {e}') sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree ) scale () \u00b6 Get the song scale and key. Returns: Name Type Description str str scale name. Source code in deluge_card/deluge_song.py 113 114 115 116 117 118 119 120 121 def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' scale_mode () \u00b6 Get the descriptive name of the song scale (mode). Returns: Name Type Description str str scale_mode name. Source code in deluge_card/deluge_song.py 101 102 103 104 105 106 107 108 109 110 111 def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' tempo () \u00b6 Get the song tempo in beats per minute. Returns: Name Type Description float float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo update_sample_element ( sample_setting ) \u00b6 Update XML element from sample_setting. Source code in deluge_card/deluge_song.py 61 62 63 64 65 66 67 def update_sample_element ( self , sample_setting ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( sample_setting . xml_path . replace ( '/song/' , '//' )) # print('DEBUG old path', elem.get('fileName')) elem . set ( 'fileName' , str ( sample_setting . sample . path )) return elem write_xml ( new_path = None ) \u00b6 Write the song XML. Source code in deluge_card/deluge_song.py 69 70 71 72 73 74 def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) Mode \u00b6 Bases: enum . Enum Enum for the scale modes. Source code in deluge_card/deluge_song.py 24 25 26 27 28 29 30 31 32 33 class Mode ( enum . Enum ): \"\"\"Enum for the scale modes.\"\"\" major = [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ] minor = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] dorian = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] phrygian = [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ] lydian = [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ] mixolydian = [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ] locrian = [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]","title":"Api"},{"location":"api/#package-deluge_card","text":"Top-level package for deluge-card.","title":"Package: deluge_card"},{"location":"api/#module-deluge_card","text":"Main class representing a Deluge Filesystem in a folder or a mounted SD card.","title":"Module deluge_card"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS","text":"Main class representing a Deluge SD card/folder structure. Attributes: Name Type Description card_root Path Path object for the root folder. Source code in deluge_card/deluge_card.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @define ( frozen = True ) class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure. Attributes: card_root (Path): Path object for the root folder. \"\"\" card_root : Path = field () @card_root . validator def _check_card_root ( self , attribute , value ): if not value . is_dir (): raise InvalidDelugeCard ( f ' { value } is not a directory path.' ) for folder in TOP_FOLDERS : if not Path ( value , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { value } ' ) @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) def samples ( self , pattern : str = \"\" ) -> Iterator [ 'Sample' ]: \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname ))","title":"DelugeCardFS"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.from_folder","text":"New instance from a Deluge Folder structure. Parameters: Name Type Description Default folder str valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 93 94 95 96 97 98 99 100 101 102 103 @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder ))","title":"from_folder()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.initialise","text":"Create a new Deluge Folder structure. Parameters: Name Type Description Default path str a valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore","title":"initialise()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.is_mounted","text":"Is this a mounted SD card. Returns: Name Type Description mounted bool True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 105 106 107 108 109 110 111 112 113 114 def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount ()","title":"is_mounted()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.samples","text":"Generator for samples in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def samples ( self , pattern : str = \"\" ) -> Iterator [ 'Sample' ]: \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname ))","title":"samples()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.songs","text":"Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile )","title":"songs()"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard","text":"Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 43 44 45 46 47 48 49 50 51 52 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str","title":"InvalidDelugeCard"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard.__init__","text":"Create a new InvalidDelugeCard Exception. Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 46 47 48 49 50 51 52 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str","title":"__init__()"},{"location":"api/#deluge_card.deluge_card.list_deluge_fs","text":"List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Yields: Name Type Description cards Iterator [ DelugeCardFS ] generator of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def list_deluge_fs ( folder ) -> Iterator [ 'DelugeCardFS' ]: \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Yields: cards (Iterator[DelugeCardFS]): generator of DelugeCardFS instances. \"\"\" def _test_card_fs ( folder ): try : return DelugeCardFS . from_folder ( folder ) except InvalidDelugeCard : return card = _test_card_fs ( folder ) if card : yield card for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if not card : continue yield card","title":"list_deluge_fs()"},{"location":"api/#module-deluge_sample","text":"Main classes representing Deluge Sample.","title":"Module: deluge_sample"},{"location":"api/#deluge_card.deluge_sample.ModOp","text":"Bases: object Represents a successful modification operation. Attributes: Name Type Description operation str str path str file path instance Any modified instance. Source code in deluge_card/deluge_sample.py 156 157 158 159 160 161 162 163 164 165 166 167 168 @define class ModOp ( object ): \"\"\"Represents a successful modification operation. Attributes: operation: str path (str): file path instance (Any): modified instance. \"\"\" operation : str path : str instance : object","title":"ModOp"},{"location":"api/#deluge_card.deluge_sample.Sample","text":"Bases: object represents a sample file. Attributes: Name Type Description path Path Path object for the sample file. settings list [ SampleSetting ] list of SampleSettings for this sample Source code in deluge_card/deluge_sample.py 129 130 131 132 133 134 135 136 137 138 139 @define # (eq=False) # frozen abuse! class Sample ( object ): \"\"\"represents a sample file. Attributes: path (Path): Path object for the sample file. settings (list[SampleSetting]): list of SampleSettings for this sample \"\"\" path : Path settings : List [ 'SampleSetting' ] = field ( factory = list , eq = False )","title":"Sample"},{"location":"api/#deluge_card.deluge_sample.SampleMoveOperation","text":"Bases: object Represents a sample file move operation. Attributes: Name Type Description old_path Path original Path. new_path Path new Path. sample Sample sample instance. Source code in deluge_card/deluge_sample.py 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 @define ( eq = False ) class SampleMoveOperation ( object ): \"\"\"Represents a sample file move operation. Attributes: old_path (Path): original Path. new_path (Path): new Path. sample (Sample): sample instance. \"\"\" old_path : Path new_path : Path sample : 'Sample' uniqid : int = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( self . old_path ) def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path )","title":"SampleMoveOperation"},{"location":"api/#deluge_card.deluge_sample.SampleMoveOperation.do_move","text":"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. Source code in deluge_card/deluge_sample.py 118 119 120 121 122 123 124 125 126 def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path )","title":"do_move()"},{"location":"api/#deluge_card.deluge_sample.SampleSetting","text":"Bases: object represents a sample in the context of a DelugeSong. Attributes: Name Type Description song_path Path Path object for the XML song file. xml_path str Xmlpath string locating the sample setting within the XML. Source code in deluge_card/deluge_sample.py 142 143 144 145 146 147 148 149 150 151 152 153 @define class SampleSetting ( object ): \"\"\"represents a sample in the context of a DelugeSong. Attributes: song_path (Path): Path object for the XML song file. xml_path (str): Xmlpath string locating the sample setting within the XML. \"\"\" song : 'deluge_song.DelugeSong' # noqa (for F821 undefined name) sample : 'Sample' xml_path : str","title":"SampleSetting"},{"location":"api/#deluge_card.deluge_sample.ensure_absolute","text":"Make sure the path is absolute, if not make it relate to the root folder. Source code in deluge_card/deluge_sample.py 50 51 52 def ensure_absolute ( root : Path , dest : Path ): \"\"\"Make sure the path is absolute, if not make it relate to the root folder.\"\"\" return dest if dest . is_absolute () else Path ( root , dest )","title":"ensure_absolute()"},{"location":"api/#deluge_card.deluge_sample.modify_sample_paths","text":"Modify sample paths just as posix mv does. Source code in deluge_card/deluge_sample.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def modify_sample_paths ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ) -> Iterator [ 'SampleMoveOperation' ]: \"\"\"Modify sample paths just as posix mv does.\"\"\" def glob_match ( sample ) -> bool : return Path ( sample . path ) . match ( pattern ) def build_move_op ( sample ) -> SampleMoveOperation : # print('DEBUG:', sample.path) if dest . suffix == '' : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest , sample . path . name ), sample ) else : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest ), sample ) sample . path = move_op . new_path . relative_to ( root ) return move_op matching_samples = filter ( glob_match , samples ) return map ( build_move_op , matching_samples )","title":"modify_sample_paths()"},{"location":"api/#deluge_card.deluge_sample.modify_sample_songs","text":"Update song XML elements. Source code in deluge_card/deluge_sample.py 36 37 38 39 40 41 42 43 44 45 46 47 def modify_sample_songs ( samples : Iterator [ 'Sample' ]) -> Iterator [ 'deluge_song.DelugeSong' ]: \"\"\"Update song XML elements.\"\"\" def update_song_elements ( sample ): # print(f\"DEBUG update_song_elements: {sample}\") for setting in sample . settings : # print(f\"DEBUG update_song_elements setting: {setting}\") elem = setting . song . update_sample_element ( setting ) assert elem . get ( 'fileName' ) == str ( setting . sample . path ) yield setting . song return itertools . chain . from_iterable ( map ( update_song_elements , samples ))","title":"modify_sample_songs()"},{"location":"api/#deluge_card.deluge_sample.mv_samples","text":"Move samples, updating any affected songs. Source code in deluge_card/deluge_sample.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def mv_samples ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ): \"\"\"Move samples, updating any affected songs.\"\"\" # print('DEBUG', root, pattern, dest) dest = ensure_absolute ( root , dest ) validate_mv_dest ( root , dest ) # raises exception if args are invalid sample_move_ops = list ( modify_sample_paths ( root , samples , pattern , dest )) # do materialise the list updated_songs = modify_sample_songs ( map ( lambda mo : mo . sample , sample_move_ops )) # write the modified XML, per unique song for song in set ( updated_songs ): song . write_xml () yield ModOp ( \"update_song_xml\" , str ( song . path ), song ) # move the files, per unique sample for move_op in set ( sample_move_ops ): move_op . do_move () yield ModOp ( \"move_file\" , str ( move_op . new_path ), move_op )","title":"mv_samples()"},{"location":"api/#deluge_card.deluge_sample.validate_mv_dest","text":"Source code in deluge_card/deluge_sample.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def validate_mv_dest ( root : Path , dest : Path ): \"\"\"Check: dest path must be a child of root and must exist.\"\"\" absolute_dest = ensure_absolute ( root , dest ) # file as target if absolute_dest . suffix : # looks like a file target if not absolute_dest . parent . exists (): raise ValueError ( f \"target folder does not exist: { dest } \" ) # folder as target elif not ( absolute_dest . is_dir ()): raise ValueError ( f \"target folder does not exist: { dest } \" ) try : absolute_dest . parent . relative_to ( root ) except ValueError : raise ValueError ( \"Destination must be a sub-folder of card.\" )","title":"validate_mv_dest()"},{"location":"api/#module-deluge_song","text":"Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js","title":"Module: deluge_song"},{"location":"api/#deluge_card.deluge_song.DelugeSong","text":"Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: Name Type Description path Path Path object for the sample file. file. Source code in deluge_card/deluge_song.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @define ( repr = False , frozen = True ) class DelugeSong : \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path xmlroot : etree . ElementTree = field () @xmlroot . default def _default_xlmroot ( self ): return etree . parse ( self . path ) . getroot () def __repr__ ( self ) -> str : return f \"DelugeSong( { self . path } )\" def update_sample_element ( self , sample_setting ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( sample_setting . xml_path . replace ( '/song/' , '//' )) # print('DEBUG old path', elem.get('fileName')) elem . set ( 'fileName' , str ( sample_setting . sample . path )) return elem def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) def sample_in_setting ( sample_file , tree ) -> Sample : sample = Sample ( Path ( sample_file )) sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) return sample for e in self . xmlroot . findall ( \".//*[@fileName]\" ): # print(f'elem {e}') sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree )","title":"DelugeSong"},{"location":"api/#deluge_card.deluge_song.DelugeSong.minimum_firmware","text":"Get the songs earliest Compatible Firmware version. Returns: Name Type Description str str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 76 77 78 79 80 81 82 def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' )","title":"minimum_firmware()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.mode_notes","text":"Get the notes in the song scale (mode). Returns: Type Description List [ int ] [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 92 93 94 95 96 97 98 99 def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ]","title":"mode_notes()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.root_note","text":"Get the root note. Returns: Name Type Description int int root note (e.g 36 for C3). Source code in deluge_card/deluge_song.py 84 85 86 87 88 89 90 def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' ))","title":"root_note()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.samples","text":"Generator for samples referenced in the DelugeSong. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_song.py 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) def sample_in_setting ( sample_file , tree ) -> Sample : sample = Sample ( Path ( sample_file )) sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) return sample for e in self . xmlroot . findall ( \".//*[@fileName]\" ): # print(f'elem {e}') sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree )","title":"samples()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.scale","text":"Get the song scale and key. Returns: Name Type Description str str scale name. Source code in deluge_card/deluge_song.py 113 114 115 116 117 118 119 120 121 def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } '","title":"scale()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.scale_mode","text":"Get the descriptive name of the song scale (mode). Returns: Name Type Description str str scale_mode name. Source code in deluge_card/deluge_song.py 101 102 103 104 105 106 107 108 109 110 111 def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other'","title":"scale_mode()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.tempo","text":"Get the song tempo in beats per minute. Returns: Name Type Description float float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo","title":"tempo()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.update_sample_element","text":"Update XML element from sample_setting. Source code in deluge_card/deluge_song.py 61 62 63 64 65 66 67 def update_sample_element ( self , sample_setting ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( sample_setting . xml_path . replace ( '/song/' , '//' )) # print('DEBUG old path', elem.get('fileName')) elem . set ( 'fileName' , str ( sample_setting . sample . path )) return elem","title":"update_sample_element()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.write_xml","text":"Write the song XML. Source code in deluge_card/deluge_song.py 69 70 71 72 73 74 def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename )","title":"write_xml()"},{"location":"api/#deluge_card.deluge_song.Mode","text":"Bases: enum . Enum Enum for the scale modes. Source code in deluge_card/deluge_song.py 24 25 26 27 28 29 30 31 32 33 class Mode ( enum . Enum ): \"\"\"Enum for the scale modes.\"\"\" major = [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ] minor = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] dorian = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] phrygian = [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ] lydian = [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ] mixolydian = [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ] locrian = [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]","title":"Mode"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 [0.4.2] - 2022-05-12 \u00b6 Changed \u00b6 fix issue 12 file not found improve reporting [0.4.1] - 2022-05-11 \u00b6 Changed \u00b6 fix path logic and validation; add validation tests; improve test cover make error tests OS independent; [0.4.0] - 2022-05-11 \u00b6 Added \u00b6 new mv_samples method. new validate_mv_dest method. more usage examples. simple scripts/dmv.py script for testing. more typing. new DelugeCardFS.from_folder() static method. list of features in README. Changed \u00b6 using attrs, some methods are now attributes. root_note, scale changes. improving docstrings. [0.3.0] - 2022-05-03 \u00b6 Added \u00b6 Posix glob-style filename matching for songs, samples, song_samples. [0.2.3] - 2022-05-02 \u00b6 Changed \u00b6 Removed dev-requirements from the published package. [0.2.2] - 2022-05-01 \u00b6 Added \u00b6 read song & sample basics deluge filesystem basics [0.1.1-alpha1] - 2022-04-30 \u00b6 Changed \u00b6 tagged release for doc publication [0.1.0] - 2022-04-30 \u00b6 Changed \u00b6 First release on PyPI.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#042---2022-05-12","text":"","title":"[0.4.2] - 2022-05-12"},{"location":"changelog/#changed","text":"fix issue 12 file not found improve reporting","title":"Changed"},{"location":"changelog/#041---2022-05-11","text":"","title":"[0.4.1] - 2022-05-11"},{"location":"changelog/#changed_1","text":"fix path logic and validation; add validation tests; improve test cover make error tests OS independent;","title":"Changed"},{"location":"changelog/#040---2022-05-11","text":"","title":"[0.4.0] - 2022-05-11"},{"location":"changelog/#added","text":"new mv_samples method. new validate_mv_dest method. more usage examples. simple scripts/dmv.py script for testing. more typing. new DelugeCardFS.from_folder() static method. list of features in README.","title":"Added"},{"location":"changelog/#changed_2","text":"using attrs, some methods are now attributes. root_note, scale changes. improving docstrings.","title":"Changed"},{"location":"changelog/#030---2022-05-03","text":"","title":"[0.3.0] - 2022-05-03"},{"location":"changelog/#added_1","text":"Posix glob-style filename matching for songs, samples, song_samples.","title":"Added"},{"location":"changelog/#023---2022-05-02","text":"","title":"[0.2.3] - 2022-05-02"},{"location":"changelog/#changed_3","text":"Removed dev-requirements from the published package.","title":"Changed"},{"location":"changelog/#022---2022-05-01","text":"","title":"[0.2.2] - 2022-05-01"},{"location":"changelog/#added_2","text":"read song & sample basics deluge filesystem basics","title":"Added"},{"location":"changelog/#011-alpha1---2022-04-30","text":"","title":"[0.1.1-alpha1] - 2022-04-30"},{"location":"changelog/#changed_4","text":"tagged release for doc publication","title":"Changed"},{"location":"changelog/#010---2022-04-30","text":"","title":"[0.1.0] - 2022-04-30"},{"location":"changelog/#changed_5","text":"First release on PyPI.","title":"Changed"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_deluge_card.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_deluge_card.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use deluge-card in a project import deluge_card list cards, and songs available at folder: \u00b6 from deluge_card import list_deluge_fs for card in list_deluge_fs('/deluge_cards/root_folder'): print(f'card at {card.path}'') # list the songs on the card for song in card.songs(): print(song, song.tempo(), song.key()) list card samples and usage: \u00b6 from deluge_card import DelugeCardFS card = DelugeCardFS('path/to/my/card') # list the samples on the card for samples in card.samples(): songs = set([s.song for s in sample.settings()]) usage = len(list(sample.settings)) print(sample, \"used in\", usage, \"settings, in\", len(songs), \"songs.\")","title":"Usage"},{"location":"usage/#usage","text":"To use deluge-card in a project import deluge_card","title":"Usage"},{"location":"usage/#list-cards-and-songs-available-at-folder","text":"from deluge_card import list_deluge_fs for card in list_deluge_fs('/deluge_cards/root_folder'): print(f'card at {card.path}'') # list the songs on the card for song in card.songs(): print(song, song.tempo(), song.key())","title":"list cards, and songs available at folder:"},{"location":"usage/#list-card-samples-and-usage","text":"from deluge_card import DelugeCardFS card = DelugeCardFS('path/to/my/card') # list the samples on the card for samples in card.samples(): songs = set([s.song for s in sample.settings()]) usage = len(list(sample.settings)) print(sample, \"used in\", usage, \"settings, in\", len(songs), \"songs.\")","title":"list card samples and usage:"}]}