{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"deluge-card \u00b6 python api for synthstrom deluge cards from fw3.15+ Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT Features \u00b6 TODO Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#deluge-card","text":"python api for synthstrom deluge cards from fw3.15+ Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT","title":"deluge-card"},{"location":"#features","text":"TODO","title":"Features"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Module: deluge_card \u00b6 Main class representing a Deluge Filesystem in a folder or a mounted SD card. DelugeCardFS \u00b6 Main class representing a Deluge SD card/folder structure. Source code in deluge_card/deluge_card.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure.\"\"\" @staticmethod def initialise ( path : str ): \"\"\"Create a new Deluge Folder structure. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) def __init__ ( self , card_root : Path ): \"\"\"Create a new DelugeCardFS instance. Args: card_root (Path): Path object for the root folder. \"\"\" self . _card_root = card_root card_root . is_dir () for folder in TOP_FOLDERS : if not Path ( card_root , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { card_root } ' ) def card_root ( self ): \"\"\"Get card root path. Returns: card_root (pathlib.Path): path of card_root. \"\"\" return self . _card_root def is_mounted ( self ): \"\"\"Is this a mounted SD card. Returns: mounted (boolean): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . _card_root ) . is_mount () def songs ( self , pattern : str = \"\" ): \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . _card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( songfile ) continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( songfile ) def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . _card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) __init__ ( card_root ) \u00b6 Create a new DelugeCardFS instance. Parameters: Name Type Description Default card_root Path Path object for the root folder. required Source code in deluge_card/deluge_card.py 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , card_root : Path ): \"\"\"Create a new DelugeCardFS instance. Args: card_root (Path): Path object for the root folder. \"\"\" self . _card_root = card_root card_root . is_dir () for folder in TOP_FOLDERS : if not Path ( card_root , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { card_root } ' ) card_root () \u00b6 Get card root path. Returns: Name Type Description card_root pathlib . Path path of card_root. Source code in deluge_card/deluge_card.py 88 89 90 91 92 93 94 def card_root ( self ): \"\"\"Get card root path. Returns: card_root (pathlib.Path): path of card_root. \"\"\" return self . _card_root initialise ( path ) staticmethod \u00b6 Create a new Deluge Folder structure. Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @staticmethod def initialise ( path : str ): \"\"\"Create a new Deluge Folder structure. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) is_mounted () \u00b6 Is this a mounted SD card. Returns: Name Type Description mounted boolean True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 96 97 98 99 100 101 102 103 104 105 def is_mounted ( self ): \"\"\"Is this a mounted SD card. Returns: mounted (boolean): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . _card_root ) . is_mount () samples ( pattern = '' ) \u00b6 Generator for samples in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . _card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) songs ( pattern = '' ) \u00b6 Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def songs ( self , pattern : str = \"\" ): \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . _card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( songfile ) continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( songfile ) InvalidDelugeCard \u00b6 Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Args: msg (str): Human readable string describing the exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" self . msg = msg __init__ ( msg ) \u00b6 Create a new InvalidDelugeCard Exception. Parameters: Name Type Description Default msg str Human readable string describing the exception. required Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Args: msg (str): Human readable string describing the exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" self . msg = msg list_deluge_fs ( folder ) \u00b6 List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Returns: Type Description [DelugeCardFS]: list of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def list_deluge_fs ( folder ): \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Returns: [DelugeCardFS]: list of DelugeCardFS instances. \"\"\" card = _test_card_fs ( folder ) if card : return [ card ] res = [] for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if card : res . append ( card ) return res Module: deluge_song \u00b6 Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js DelugeSong \u00b6 Class representing song data on a DelugeCard (in SONGS/*.xml). Source code in deluge_card/deluge_song.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 class DelugeSong : \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml).\"\"\" def __init__ ( self , filepath : Path ): \"\"\"Create a new DelugeSong instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _xmlroot = None def path ( self ): \"\"\"Path object for the song XML file.\"\"\" return self . _filepath def __repr__ ( self ): return f \"DelugeSong( { self . _filepath } )\" def xmlroot ( self ): \"\"\"Get the xmlroot of the songs XML document.\"\"\" if self . _xmlroot is None : self . _xmlroot = etree . parse ( self . _filepath ) . getroot () assert self . _xmlroot . tag == 'song' return self . _xmlroot def minimum_firmware ( self ): \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" root = self . xmlroot () return root . get ( 'earliestCompatibleFirmware' ) def root_note ( self ): \"\"\"Get the root note. Returns: str: root note (e.g C). \"\"\" root = self . xmlroot () note = int ( root . get ( 'rootNote' )) % 12 try : return NOTES [ note + C3_IDX ] except IndexError as err : print ( f 'note { note } { err } ' ) return \"64\" def mode_notes ( self ): \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" root = self . xmlroot () notes = root . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ): \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ]: return 'major' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'minor' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'dorian' if mn == [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ]: return 'phrygian' if mn == [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ]: return 'lydian' if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ]: return 'mixolydian' if mn == [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]: return 'locrian' def scale ( self ): \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root = self . root_note () return f ' { root [: - 1 ] } { mode } ' def tempo ( self ): \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } root = self . xmlroot () fractPart = ( int ( root . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( root . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" root = self . xmlroot () tree = etree . ElementTree ( root ) def sample_in_setting ( sample_file , tree ): sample = Sample ( Path ( sample_file )) sample . add_setting ( SampleSetting ( self . _filepath , tree . getpath ( e ))) return sample for sample_path in [ './/instruments/kit/soundSources/sound/osc1' , './/instruments/kit/soundSources/sound/osc2' , './/osc1/sampleRanges/sampleRange' , ]: for e in root . findall ( sample_path ): sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree ) __init__ ( filepath ) \u00b6 Create a new DelugeSong instance. Parameters: Name Type Description Default filepath Path Path object for the sample. required Source code in deluge_card/deluge_song.py 79 80 81 82 83 84 85 86 def __init__ ( self , filepath : Path ): \"\"\"Create a new DelugeSong instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _xmlroot = None minimum_firmware () \u00b6 Get the songs earliest Compatible Firmware version. Returns: Name Type Description str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 102 103 104 105 106 107 108 109 def minimum_firmware ( self ): \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" root = self . xmlroot () return root . get ( 'earliestCompatibleFirmware' ) mode_notes () \u00b6 Get the notes in the song scale (mode). Returns: Type Description [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 125 126 127 128 129 130 131 132 133 def mode_notes ( self ): \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" root = self . xmlroot () notes = root . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] path () \u00b6 Path object for the song XML file. Source code in deluge_card/deluge_song.py 88 89 90 def path ( self ): \"\"\"Path object for the song XML file.\"\"\" return self . _filepath root_note () \u00b6 Get the root note. Returns: Name Type Description str root note (e.g C). Source code in deluge_card/deluge_song.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def root_note ( self ): \"\"\"Get the root note. Returns: str: root note (e.g C). \"\"\" root = self . xmlroot () note = int ( root . get ( 'rootNote' )) % 12 try : return NOTES [ note + C3_IDX ] except IndexError as err : print ( f 'note { note } { err } ' ) return \"64\" samples ( pattern = '' ) \u00b6 Generator for samples referenced in the DelugeSong. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_song.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" root = self . xmlroot () tree = etree . ElementTree ( root ) def sample_in_setting ( sample_file , tree ): sample = Sample ( Path ( sample_file )) sample . add_setting ( SampleSetting ( self . _filepath , tree . getpath ( e ))) return sample for sample_path in [ './/instruments/kit/soundSources/sound/osc1' , './/instruments/kit/soundSources/sound/osc2' , './/osc1/sampleRanges/sampleRange' , ]: for e in root . findall ( sample_path ): sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree ) scale () \u00b6 Get the song scale and key. Returns: Name Type Description str scale name. Source code in deluge_card/deluge_song.py 157 158 159 160 161 162 163 164 165 def scale ( self ): \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root = self . root_note () return f ' { root [: - 1 ] } { mode } ' scale_mode () \u00b6 Get the descriptive name of the song scale (mode). Returns: Name Type Description str scale_mode name. Source code in deluge_card/deluge_song.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def scale_mode ( self ): \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ]: return 'major' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'minor' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'dorian' if mn == [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ]: return 'phrygian' if mn == [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ]: return 'lydian' if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ]: return 'mixolydian' if mn == [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]: return 'locrian' tempo () \u00b6 Get the song tempo in beats per minute. Returns: Name Type Description float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def tempo ( self ): \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } root = self . xmlroot () fractPart = ( int ( root . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( root . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo xmlroot () \u00b6 Get the xmlroot of the songs XML document. Source code in deluge_card/deluge_song.py 95 96 97 98 99 100 def xmlroot ( self ): \"\"\"Get the xmlroot of the songs XML document.\"\"\" if self . _xmlroot is None : self . _xmlroot = etree . parse ( self . _filepath ) . getroot () assert self . _xmlroot . tag == 'song' return self . _xmlroot Sample \u00b6 Class representing a Sample file. Source code in deluge_card/deluge_song.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Sample : \"\"\"Class representing a Sample file.\"\"\" def __init__ ( self , filepath : Path ): \"\"\"Create a new Sample instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _song_settings : typing . Dict [ str , SampleSetting ] = {} def add_setting ( self , sample_setting ): \"\"\"Add a sample setting. sample. Args: sample_setting (SampleSetting): sample setting. \"\"\" self . _song_settings [ sample_setting . xml_path ()] = sample_setting def path ( self ): \"\"\"Path object for the sample.\"\"\" return self . _filepath def settings ( self ): \"\"\"Settings for the song.\"\"\" return self . _song_settings def __repr__ ( self ): return f \"Sample( { self . _filepath } )\" __init__ ( filepath ) \u00b6 Create a new Sample instance. Parameters: Name Type Description Default filepath Path Path object for the sample. required Source code in deluge_card/deluge_song.py 47 48 49 50 51 52 53 54 def __init__ ( self , filepath : Path ): \"\"\"Create a new Sample instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _song_settings : typing . Dict [ str , SampleSetting ] = {} add_setting ( sample_setting ) \u00b6 Add a sample setting. sample. Parameters: Name Type Description Default sample_setting SampleSetting sample setting. required Source code in deluge_card/deluge_song.py 56 57 58 59 60 61 62 def add_setting ( self , sample_setting ): \"\"\"Add a sample setting. sample. Args: sample_setting (SampleSetting): sample setting. \"\"\" self . _song_settings [ sample_setting . xml_path ()] = sample_setting path () \u00b6 Path object for the sample. Source code in deluge_card/deluge_song.py 64 65 66 def path ( self ): \"\"\"Path object for the sample.\"\"\" return self . _filepath settings () \u00b6 Settings for the song. Source code in deluge_card/deluge_song.py 68 69 70 def settings ( self ): \"\"\"Settings for the song.\"\"\" return self . _song_settings SampleSetting \u00b6 Class representing a sample in the context of a DelugeSong. Source code in deluge_card/deluge_song.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SampleSetting : \"\"\"Class representing a sample in the context of a DelugeSong.\"\"\" def __init__ ( self , song_path , xml_path ): \"\"\"Create a new SampleSetting instance. Args: song_path (Path): Path object for the song. xml_path (str): Xmlpath string for the song context. \"\"\" self . _song_path = song_path self . _xml_path = xml_path def xml_path ( self ): \"\"\"Path object for the song.\"\"\" return self . _xml_path def song_path ( self ): \"\"\"Xmlpath string for the song context.\"\"\" return self . _song_path def __repr__ ( self ): return f \"SampleSetting( { self . _xml_path } )\" __init__ ( song_path , xml_path ) \u00b6 Create a new SampleSetting instance. Parameters: Name Type Description Default song_path Path Path object for the song. required xml_path str Xmlpath string for the song context. required Source code in deluge_card/deluge_song.py 22 23 24 25 26 27 28 29 30 def __init__ ( self , song_path , xml_path ): \"\"\"Create a new SampleSetting instance. Args: song_path (Path): Path object for the song. xml_path (str): Xmlpath string for the song context. \"\"\" self . _song_path = song_path self . _xml_path = xml_path song_path () \u00b6 Xmlpath string for the song context. Source code in deluge_card/deluge_song.py 36 37 38 def song_path ( self ): \"\"\"Xmlpath string for the song context.\"\"\" return self . _song_path xml_path () \u00b6 Path object for the song. Source code in deluge_card/deluge_song.py 32 33 34 def xml_path ( self ): \"\"\"Path object for the song.\"\"\" return self . _xml_path","title":"Modules"},{"location":"api/#module-deluge_card","text":"Main class representing a Deluge Filesystem in a folder or a mounted SD card.","title":"Module: deluge_card"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS","text":"Main class representing a Deluge SD card/folder structure. Source code in deluge_card/deluge_card.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure.\"\"\" @staticmethod def initialise ( path : str ): \"\"\"Create a new Deluge Folder structure. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) def __init__ ( self , card_root : Path ): \"\"\"Create a new DelugeCardFS instance. Args: card_root (Path): Path object for the root folder. \"\"\" self . _card_root = card_root card_root . is_dir () for folder in TOP_FOLDERS : if not Path ( card_root , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { card_root } ' ) def card_root ( self ): \"\"\"Get card root path. Returns: card_root (pathlib.Path): path of card_root. \"\"\" return self . _card_root def is_mounted ( self ): \"\"\"Is this a mounted SD card. Returns: mounted (boolean): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . _card_root ) . is_mount () def songs ( self , pattern : str = \"\" ): \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . _card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( songfile ) continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( songfile ) def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . _card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname ))","title":"DelugeCardFS"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.__init__","text":"Create a new DelugeCardFS instance. Parameters: Name Type Description Default card_root Path Path object for the root folder. required Source code in deluge_card/deluge_card.py 76 77 78 79 80 81 82 83 84 85 86 def __init__ ( self , card_root : Path ): \"\"\"Create a new DelugeCardFS instance. Args: card_root (Path): Path object for the root folder. \"\"\" self . _card_root = card_root card_root . is_dir () for folder in TOP_FOLDERS : if not Path ( card_root , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { card_root } ' )","title":"__init__()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.card_root","text":"Get card root path. Returns: Name Type Description card_root pathlib . Path path of card_root. Source code in deluge_card/deluge_card.py 88 89 90 91 92 93 94 def card_root ( self ): \"\"\"Get card root path. Returns: card_root (pathlib.Path): path of card_root. \"\"\" return self . _card_root","title":"card_root()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.initialise","text":"Create a new Deluge Folder structure. Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 @staticmethod def initialise ( path : str ): \"\"\"Create a new Deluge Folder structure. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root )","title":"initialise()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.is_mounted","text":"Is this a mounted SD card. Returns: Name Type Description mounted boolean True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 96 97 98 99 100 101 102 103 104 105 def is_mounted ( self ): \"\"\"Is this a mounted SD card. Returns: mounted (boolean): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . _card_root ) . is_mount ()","title":"is_mounted()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.samples","text":"Generator for samples in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" smp = Path ( self . _card_root , SAMPLES ) paths = ( p . resolve () for p in Path ( smp ) . glob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname ))","title":"samples()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.songs","text":"Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 def songs ( self , pattern : str = \"\" ): \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . _card_root , SONGS ) . glob ( '*.XML' )): if not pattern : yield DelugeSong ( songfile ) continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( songfile )","title":"songs()"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard","text":"Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 41 42 43 44 45 46 47 48 49 50 51 52 53 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Args: msg (str): Human readable string describing the exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" self . msg = msg","title":"InvalidDelugeCard"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard.__init__","text":"Create a new InvalidDelugeCard Exception. Parameters: Name Type Description Default msg str Human readable string describing the exception. required Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Args: msg (str): Human readable string describing the exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" self . msg = msg","title":"__init__()"},{"location":"api/#deluge_card.deluge_card.list_deluge_fs","text":"List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Returns: Type Description [DelugeCardFS]: list of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def list_deluge_fs ( folder ): \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Returns: [DelugeCardFS]: list of DelugeCardFS instances. \"\"\" card = _test_card_fs ( folder ) if card : return [ card ] res = [] for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if card : res . append ( card ) return res","title":"list_deluge_fs()"},{"location":"api/#module-deluge_song","text":"Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js","title":"Module: deluge_song"},{"location":"api/#deluge_card.deluge_song.DelugeSong","text":"Class representing song data on a DelugeCard (in SONGS/*.xml). Source code in deluge_card/deluge_song.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 class DelugeSong : \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml).\"\"\" def __init__ ( self , filepath : Path ): \"\"\"Create a new DelugeSong instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _xmlroot = None def path ( self ): \"\"\"Path object for the song XML file.\"\"\" return self . _filepath def __repr__ ( self ): return f \"DelugeSong( { self . _filepath } )\" def xmlroot ( self ): \"\"\"Get the xmlroot of the songs XML document.\"\"\" if self . _xmlroot is None : self . _xmlroot = etree . parse ( self . _filepath ) . getroot () assert self . _xmlroot . tag == 'song' return self . _xmlroot def minimum_firmware ( self ): \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" root = self . xmlroot () return root . get ( 'earliestCompatibleFirmware' ) def root_note ( self ): \"\"\"Get the root note. Returns: str: root note (e.g C). \"\"\" root = self . xmlroot () note = int ( root . get ( 'rootNote' )) % 12 try : return NOTES [ note + C3_IDX ] except IndexError as err : print ( f 'note { note } { err } ' ) return \"64\" def mode_notes ( self ): \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" root = self . xmlroot () notes = root . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ): \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ]: return 'major' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'minor' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'dorian' if mn == [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ]: return 'phrygian' if mn == [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ]: return 'lydian' if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ]: return 'mixolydian' if mn == [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]: return 'locrian' def scale ( self ): \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root = self . root_note () return f ' { root [: - 1 ] } { mode } ' def tempo ( self ): \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } root = self . xmlroot () fractPart = ( int ( root . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( root . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" root = self . xmlroot () tree = etree . ElementTree ( root ) def sample_in_setting ( sample_file , tree ): sample = Sample ( Path ( sample_file )) sample . add_setting ( SampleSetting ( self . _filepath , tree . getpath ( e ))) return sample for sample_path in [ './/instruments/kit/soundSources/sound/osc1' , './/instruments/kit/soundSources/sound/osc2' , './/osc1/sampleRanges/sampleRange' , ]: for e in root . findall ( sample_path ): sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree )","title":"DelugeSong"},{"location":"api/#deluge_card.deluge_song.DelugeSong.__init__","text":"Create a new DelugeSong instance. Parameters: Name Type Description Default filepath Path Path object for the sample. required Source code in deluge_card/deluge_song.py 79 80 81 82 83 84 85 86 def __init__ ( self , filepath : Path ): \"\"\"Create a new DelugeSong instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _xmlroot = None","title":"__init__()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.minimum_firmware","text":"Get the songs earliest Compatible Firmware version. Returns: Name Type Description str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 102 103 104 105 106 107 108 109 def minimum_firmware ( self ): \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" root = self . xmlroot () return root . get ( 'earliestCompatibleFirmware' )","title":"minimum_firmware()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.mode_notes","text":"Get the notes in the song scale (mode). Returns: Type Description [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 125 126 127 128 129 130 131 132 133 def mode_notes ( self ): \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" root = self . xmlroot () notes = root . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ]","title":"mode_notes()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.path","text":"Path object for the song XML file. Source code in deluge_card/deluge_song.py 88 89 90 def path ( self ): \"\"\"Path object for the song XML file.\"\"\" return self . _filepath","title":"path()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.root_note","text":"Get the root note. Returns: Name Type Description str root note (e.g C). Source code in deluge_card/deluge_song.py 111 112 113 114 115 116 117 118 119 120 121 122 123 def root_note ( self ): \"\"\"Get the root note. Returns: str: root note (e.g C). \"\"\" root = self . xmlroot () note = int ( root . get ( 'rootNote' )) % 12 try : return NOTES [ note + C3_IDX ] except IndexError as err : print ( f 'note { note } { err } ' ) return \"64\"","title":"root_note()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.samples","text":"Generator for samples referenced in the DelugeSong. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_song.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 def samples ( self , pattern : str = \"\" ): \"\"\"Generator for samples referenced in the DelugeSong. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" root = self . xmlroot () tree = etree . ElementTree ( root ) def sample_in_setting ( sample_file , tree ): sample = Sample ( Path ( sample_file )) sample . add_setting ( SampleSetting ( self . _filepath , tree . getpath ( e ))) return sample for sample_path in [ './/instruments/kit/soundSources/sound/osc1' , './/instruments/kit/soundSources/sound/osc2' , './/osc1/sampleRanges/sampleRange' , ]: for e in root . findall ( sample_path ): sample_file = e . get ( 'fileName' ) if sample_file : if not pattern : yield sample_in_setting ( sample_file , tree ) continue if PurePath ( sample_file ) . match ( pattern ): yield sample_in_setting ( sample_file , tree )","title":"samples()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.scale","text":"Get the song scale and key. Returns: Name Type Description str scale name. Source code in deluge_card/deluge_song.py 157 158 159 160 161 162 163 164 165 def scale ( self ): \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root = self . root_note () return f ' { root [: - 1 ] } { mode } '","title":"scale()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.scale_mode","text":"Get the descriptive name of the song scale (mode). Returns: Name Type Description str scale_mode name. Source code in deluge_card/deluge_song.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def scale_mode ( self ): \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ]: return 'major' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'minor' if mn == [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ]: return 'dorian' if mn == [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ]: return 'phrygian' if mn == [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ]: return 'lydian' if mn == [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ]: return 'mixolydian' if mn == [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]: return 'locrian'","title":"scale_mode()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.tempo","text":"Get the song tempo in beats per minute. Returns: Name Type Description float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 def tempo ( self ): \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } root = self . xmlroot () fractPart = ( int ( root . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( root . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo","title":"tempo()"},{"location":"api/#deluge_card.deluge_song.DelugeSong.xmlroot","text":"Get the xmlroot of the songs XML document. Source code in deluge_card/deluge_song.py 95 96 97 98 99 100 def xmlroot ( self ): \"\"\"Get the xmlroot of the songs XML document.\"\"\" if self . _xmlroot is None : self . _xmlroot = etree . parse ( self . _filepath ) . getroot () assert self . _xmlroot . tag == 'song' return self . _xmlroot","title":"xmlroot()"},{"location":"api/#deluge_card.deluge_song.Sample","text":"Class representing a Sample file. Source code in deluge_card/deluge_song.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Sample : \"\"\"Class representing a Sample file.\"\"\" def __init__ ( self , filepath : Path ): \"\"\"Create a new Sample instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _song_settings : typing . Dict [ str , SampleSetting ] = {} def add_setting ( self , sample_setting ): \"\"\"Add a sample setting. sample. Args: sample_setting (SampleSetting): sample setting. \"\"\" self . _song_settings [ sample_setting . xml_path ()] = sample_setting def path ( self ): \"\"\"Path object for the sample.\"\"\" return self . _filepath def settings ( self ): \"\"\"Settings for the song.\"\"\" return self . _song_settings def __repr__ ( self ): return f \"Sample( { self . _filepath } )\"","title":"Sample"},{"location":"api/#deluge_card.deluge_song.Sample.__init__","text":"Create a new Sample instance. Parameters: Name Type Description Default filepath Path Path object for the sample. required Source code in deluge_card/deluge_song.py 47 48 49 50 51 52 53 54 def __init__ ( self , filepath : Path ): \"\"\"Create a new Sample instance. Args: filepath (Path): Path object for the sample. \"\"\" self . _filepath = filepath self . _song_settings : typing . Dict [ str , SampleSetting ] = {}","title":"__init__()"},{"location":"api/#deluge_card.deluge_song.Sample.add_setting","text":"Add a sample setting. sample. Parameters: Name Type Description Default sample_setting SampleSetting sample setting. required Source code in deluge_card/deluge_song.py 56 57 58 59 60 61 62 def add_setting ( self , sample_setting ): \"\"\"Add a sample setting. sample. Args: sample_setting (SampleSetting): sample setting. \"\"\" self . _song_settings [ sample_setting . xml_path ()] = sample_setting","title":"add_setting()"},{"location":"api/#deluge_card.deluge_song.Sample.path","text":"Path object for the sample. Source code in deluge_card/deluge_song.py 64 65 66 def path ( self ): \"\"\"Path object for the sample.\"\"\" return self . _filepath","title":"path()"},{"location":"api/#deluge_card.deluge_song.Sample.settings","text":"Settings for the song. Source code in deluge_card/deluge_song.py 68 69 70 def settings ( self ): \"\"\"Settings for the song.\"\"\" return self . _song_settings","title":"settings()"},{"location":"api/#deluge_card.deluge_song.SampleSetting","text":"Class representing a sample in the context of a DelugeSong. Source code in deluge_card/deluge_song.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class SampleSetting : \"\"\"Class representing a sample in the context of a DelugeSong.\"\"\" def __init__ ( self , song_path , xml_path ): \"\"\"Create a new SampleSetting instance. Args: song_path (Path): Path object for the song. xml_path (str): Xmlpath string for the song context. \"\"\" self . _song_path = song_path self . _xml_path = xml_path def xml_path ( self ): \"\"\"Path object for the song.\"\"\" return self . _xml_path def song_path ( self ): \"\"\"Xmlpath string for the song context.\"\"\" return self . _song_path def __repr__ ( self ): return f \"SampleSetting( { self . _xml_path } )\"","title":"SampleSetting"},{"location":"api/#deluge_card.deluge_song.SampleSetting.__init__","text":"Create a new SampleSetting instance. Parameters: Name Type Description Default song_path Path Path object for the song. required xml_path str Xmlpath string for the song context. required Source code in deluge_card/deluge_song.py 22 23 24 25 26 27 28 29 30 def __init__ ( self , song_path , xml_path ): \"\"\"Create a new SampleSetting instance. Args: song_path (Path): Path object for the song. xml_path (str): Xmlpath string for the song context. \"\"\" self . _song_path = song_path self . _xml_path = xml_path","title":"__init__()"},{"location":"api/#deluge_card.deluge_song.SampleSetting.song_path","text":"Xmlpath string for the song context. Source code in deluge_card/deluge_song.py 36 37 38 def song_path ( self ): \"\"\"Xmlpath string for the song context.\"\"\" return self . _song_path","title":"song_path()"},{"location":"api/#deluge_card.deluge_song.SampleSetting.xml_path","text":"Path object for the song. Source code in deluge_card/deluge_song.py 32 33 34 def xml_path ( self ): \"\"\"Path object for the song.\"\"\" return self . _xml_path","title":"xml_path()"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 [0.3.0] - 2022-05-03 \u00b6 Added \u00b6 Posix glob-style filename matching for songs, samples, song_samples. [0.2.3] - 2022-05-02 \u00b6 Changed \u00b6 Removed dev-requirements from the published package. [0.2.2] - 2022-05-01 \u00b6 Added \u00b6 read song & sample basics deluge filesystem basics [0.1.1-alpha1] - 2022-04-30 \u00b6 Changed \u00b6 tagged release for doc publication [0.1.0] - 2022-04-30 \u00b6 Changed \u00b6 First release on PyPI.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#030---2022-05-03","text":"","title":"[0.3.0] - 2022-05-03"},{"location":"changelog/#added","text":"Posix glob-style filename matching for songs, samples, song_samples.","title":"Added"},{"location":"changelog/#023---2022-05-02","text":"","title":"[0.2.3] - 2022-05-02"},{"location":"changelog/#changed","text":"Removed dev-requirements from the published package.","title":"Changed"},{"location":"changelog/#022---2022-05-01","text":"","title":"[0.2.2] - 2022-05-01"},{"location":"changelog/#added_1","text":"read song & sample basics deluge filesystem basics","title":"Added"},{"location":"changelog/#011-alpha1---2022-04-30","text":"","title":"[0.1.1-alpha1] - 2022-04-30"},{"location":"changelog/#changed_1","text":"tagged release for doc publication","title":"Changed"},{"location":"changelog/#010---2022-04-30","text":"","title":"[0.1.0] - 2022-04-30"},{"location":"changelog/#changed_2","text":"First release on PyPI.","title":"Changed"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_deluge_card.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_deluge_card.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use deluge-card in a project import deluge_card","title":"Usage"},{"location":"usage/#usage","text":"To use deluge-card in a project import deluge_card","title":"Usage"}]}