{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"deluge-card \u00b6 A Python3 api for Synthstrom Audible Deluge SD cards. Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT Features \u00b6 List sub-folders that resemble Deluge cards (DelugeCardFS). List contents of deluge filesystems (cards , folders). Get details of card contents: songs, samples, sample usage. Get song details like tempo , key , scale . Filter contents by paths, using posix ls glob patterns. Move samples like posix mv . Unit tested on Macosx, Linux & Windows, Python 3.8+. Song XML from fw3.15. Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#deluge-card","text":"A Python3 api for Synthstrom Audible Deluge SD cards. Documentation: https://mupaduw.github.io/deluge-card GitHub: https://github.com/mupaduw/deluge-card PyPI: https://pypi.org/project/deluge-card/ Free software: MIT","title":"deluge-card"},{"location":"#features","text":"List sub-folders that resemble Deluge cards (DelugeCardFS). List contents of deluge filesystems (cards , folders). Get details of card contents: songs, samples, sample usage. Get song details like tempo , key , scale . Filter contents by paths, using posix ls glob patterns. Move samples like posix mv . Unit tested on Macosx, Linux & Windows, Python 3.8+. Song XML from fw3.15.","title":"Features"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Package: deluge_card \u00b6 Top-level package for deluge-card. Module deluge_card \u00b6 Main class representing a Deluge Filesystem in a folder or a mounted SD card. DelugeCardFS \u00b6 Main class representing a Deluge SD card/folder structure. Attributes: Name Type Description card_root Path Path object for the root folder. Source code in deluge_card/deluge_card.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @define ( frozen = True ) class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure. Attributes: card_root (Path): Path object for the root folder. \"\"\" card_root : Path = field () @card_root . validator def _check_card_root ( self , attribute , value ): if not value . is_dir (): raise InvalidDelugeCard ( f ' { value } is not a directory path.' ) for folder in TOP_FOLDERS : if not Path ( value , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { value } ' ) @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) def kits ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeKit' ]: \"\"\"Generator for kits in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeKit): the next kit on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , KITS ) . rglob ( '*.XML' )): if not pattern : yield DelugeKit ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeKit ( self , filepath ) def synths ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSynth' ]: \"\"\"Generator for synths in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSynth): the next synth on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , SYNTHS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSynth ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeSynth ( self , filepath ) def _sample_files ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): matching samples. \"\"\" smp = Path ( self . card_root , 'SAMPLES' ) paths = ( p . resolve () for p in Path ( smp ) . rglob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : # print(fname) if Path ( fname ) . name [ 0 ] == '.' : # Apple copy crap continue if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) def mv_samples ( self , pattern : str , dest : Path ) -> Iterator [ ModOp ]: \"\"\"Move samples, updating any affected XML files. Args: pattern (str): glob-style filename pattern. dest: (Path): new path for the moved objec(s) Yields: object (ModOp): Details of the move operation. \"\"\" yield from mv_samples ( self . card_root , self . samples ( pattern ), pattern , dest ) def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for all samples in the card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_samples = self . used_samples ( pattern ) all_samples = self . _sample_files ( pattern ) for sample in used_samples : sample_map [ sample . path ] = sample yield sample for sample in all_samples : if sample . path not in sample_map : sample_map [ sample . path ] = sample yield sample def used_samples ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples referenced in XML files. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_sample_gens = itertools . chain ( map ( lambda synth : synth . samples ( pattern ), self . synths ()), map ( lambda sng : sng . samples ( pattern ), self . songs ()), map ( lambda kit : kit . samples ( pattern ), self . kits ()), ) # merge samples in different settings (song, kit, synth) for sample in itertools . chain . from_iterable ( used_sample_gens ): if sample . path in sample_map : sample_map [ sample . path ] . settings += sample . settings else : sample_map [ sample . path ] = sample return ( s for s in sample_map . values ()) _sample_files ( pattern = '' ) \u00b6 Get all samples. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample matching samples. Source code in deluge_card/deluge_card.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def _sample_files ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): matching samples. \"\"\" smp = Path ( self . card_root , 'SAMPLES' ) paths = ( p . resolve () for p in Path ( smp ) . rglob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : # print(fname) if Path ( fname ) . name [ 0 ] == '.' : # Apple copy crap continue if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) from_folder ( folder ) staticmethod \u00b6 New instance from a Deluge Folder structure. Parameters: Name Type Description Default folder str valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 98 99 100 101 102 103 104 105 106 107 108 @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) initialise ( path ) staticmethod \u00b6 Create a new Deluge Folder structure. Parameters: Name Type Description Default path str a valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore is_mounted () \u00b6 Is this a mounted SD card. Returns: Name Type Description mounted bool True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 110 111 112 113 114 115 116 117 118 119 def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () kits ( pattern = '' ) \u00b6 Generator for kits in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeKit the next kit on the card. Source code in deluge_card/deluge_card.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def kits ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeKit' ]: \"\"\"Generator for kits in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeKit): the next kit on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , KITS ) . rglob ( '*.XML' )): if not pattern : yield DelugeKit ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeKit ( self , filepath ) mv_samples ( pattern , dest ) \u00b6 Move samples, updating any affected XML files. Parameters: Name Type Description Default pattern str glob-style filename pattern. required dest Path (Path): new path for the moved objec(s) required Yields: Name Type Description object ModOp Details of the move operation. Source code in deluge_card/deluge_card.py 190 191 192 193 194 195 196 197 198 199 200 def mv_samples ( self , pattern : str , dest : Path ) -> Iterator [ ModOp ]: \"\"\"Move samples, updating any affected XML files. Args: pattern (str): glob-style filename pattern. dest: (Path): new path for the moved objec(s) Yields: object (ModOp): Details of the move operation. \"\"\" yield from mv_samples ( self . card_root , self . samples ( pattern ), pattern , dest ) samples ( pattern = '' ) \u00b6 Generator for all samples in the card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for all samples in the card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_samples = self . used_samples ( pattern ) all_samples = self . _sample_files ( pattern ) for sample in used_samples : sample_map [ sample . path ] = sample yield sample for sample in all_samples : if sample . path not in sample_map : sample_map [ sample . path ] = sample yield sample songs ( pattern = '' ) \u00b6 Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) synths ( pattern = '' ) \u00b6 Generator for synths in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSynth the next synth on the card. Source code in deluge_card/deluge_card.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def synths ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSynth' ]: \"\"\"Generator for synths in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSynth): the next synth on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , SYNTHS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSynth ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeSynth ( self , filepath ) used_samples ( pattern = '' ) \u00b6 Get all samples referenced in XML files. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def used_samples ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples referenced in XML files. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_sample_gens = itertools . chain ( map ( lambda synth : synth . samples ( pattern ), self . synths ()), map ( lambda sng : sng . samples ( pattern ), self . songs ()), map ( lambda kit : kit . samples ( pattern ), self . kits ()), ) # merge samples in different settings (song, kit, synth) for sample in itertools . chain . from_iterable ( used_sample_gens ): if sample . path in sample_map : sample_map [ sample . path ] . settings += sample . settings else : sample_map [ sample . path ] = sample return ( s for s in sample_map . values ()) InvalidDelugeCard \u00b6 Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 48 49 50 51 52 53 54 55 56 57 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str __init__ ( msg ) \u00b6 Create a new InvalidDelugeCard Exception. Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 51 52 53 54 55 56 57 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str list_deluge_fs ( folder ) \u00b6 List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Yields: Name Type Description cards Iterator [ DelugeCardFS ] generator of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def list_deluge_fs ( folder ) -> Iterator [ 'DelugeCardFS' ]: \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Yields: cards (Iterator[DelugeCardFS]): generator of DelugeCardFS instances. \"\"\" def _test_card_fs ( folder ): try : return DelugeCardFS . from_folder ( folder ) except InvalidDelugeCard : return card = _test_card_fs ( folder ) if card : yield card for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if not card : continue yield card","title":"Main"},{"location":"api/#package-deluge_card","text":"Top-level package for deluge-card.","title":"Package: deluge_card"},{"location":"api/#module-deluge_card","text":"Main class representing a Deluge Filesystem in a folder or a mounted SD card.","title":"Module deluge_card"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS","text":"Main class representing a Deluge SD card/folder structure. Attributes: Name Type Description card_root Path Path object for the root folder. Source code in deluge_card/deluge_card.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 @define ( frozen = True ) class DelugeCardFS : \"\"\"Main class representing a Deluge SD card/folder structure. Attributes: card_root (Path): Path object for the root folder. \"\"\" card_root : Path = field () @card_root . validator def _check_card_root ( self , attribute , value ): if not value . is_dir (): raise InvalidDelugeCard ( f ' { value } is not a directory path.' ) for folder in TOP_FOLDERS : if not Path ( value , folder ) . exists (): raise InvalidDelugeCard ( f 'required folder { folder } does not exist in path { value } ' ) @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder )) def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount () def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile ) def kits ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeKit' ]: \"\"\"Generator for kits in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeKit): the next kit on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , KITS ) . rglob ( '*.XML' )): if not pattern : yield DelugeKit ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeKit ( self , filepath ) def synths ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSynth' ]: \"\"\"Generator for synths in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSynth): the next synth on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , SYNTHS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSynth ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeSynth ( self , filepath ) def _sample_files ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): matching samples. \"\"\" smp = Path ( self . card_root , 'SAMPLES' ) paths = ( p . resolve () for p in Path ( smp ) . rglob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : # print(fname) if Path ( fname ) . name [ 0 ] == '.' : # Apple copy crap continue if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname )) def mv_samples ( self , pattern : str , dest : Path ) -> Iterator [ ModOp ]: \"\"\"Move samples, updating any affected XML files. Args: pattern (str): glob-style filename pattern. dest: (Path): new path for the moved objec(s) Yields: object (ModOp): Details of the move operation. \"\"\" yield from mv_samples ( self . card_root , self . samples ( pattern ), pattern , dest ) def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for all samples in the card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_samples = self . used_samples ( pattern ) all_samples = self . _sample_files ( pattern ) for sample in used_samples : sample_map [ sample . path ] = sample yield sample for sample in all_samples : if sample . path not in sample_map : sample_map [ sample . path ] = sample yield sample def used_samples ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples referenced in XML files. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_sample_gens = itertools . chain ( map ( lambda synth : synth . samples ( pattern ), self . synths ()), map ( lambda sng : sng . samples ( pattern ), self . songs ()), map ( lambda kit : kit . samples ( pattern ), self . kits ()), ) # merge samples in different settings (song, kit, synth) for sample in itertools . chain . from_iterable ( used_sample_gens ): if sample . path in sample_map : sample_map [ sample . path ] . settings += sample . settings else : sample_map [ sample . path ] = sample return ( s for s in sample_map . values ())","title":"DelugeCardFS"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS._sample_files","text":"Get all samples. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample matching samples. Source code in deluge_card/deluge_card.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def _sample_files ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): matching samples. \"\"\" smp = Path ( self . card_root , 'SAMPLES' ) paths = ( p . resolve () for p in Path ( smp ) . rglob ( \"**/*\" ) if p . suffix . lower () in SAMPLE_TYPES ) for fname in paths : # print(fname) if Path ( fname ) . name [ 0 ] == '.' : # Apple copy crap continue if not pattern : yield Sample ( Path ( fname )) continue if PurePath ( fname ) . match ( pattern ): yield Sample ( Path ( fname ))","title":"_sample_files()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.from_folder","text":"New instance from a Deluge Folder structure. Parameters: Name Type Description Default folder str valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 98 99 100 101 102 103 104 105 106 107 108 @staticmethod def from_folder ( folder : str ) -> 'DelugeCardFS' : \"\"\"New instance from a Deluge Folder structure. Args: folder (str): valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" return DelugeCardFS ( Path ( folder ))","title":"from_folder()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.initialise","text":"Create a new Deluge Folder structure. Parameters: Name Type Description Default path str a valid folder name. required Returns: Name Type Description instance DelugeCardFS new instance. Source code in deluge_card/deluge_card.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 @staticmethod def initialise ( path : str ) -> 'DelugeCardFS' : \"\"\"Create a new Deluge Folder structure. Args: path (str): a valid folder name. Returns: instance (DelugeCardFS): new instance. \"\"\" card_root = Path ( path ) assert card_root . is_dir () # assert card_root.is_mount() assert len ( list ( card_root . iterdir ())) == 0 for folder in TOP_FOLDERS : Path ( card_root , folder ) . mkdir () return DelugeCardFS ( card_root ) # type: ignore","title":"initialise()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.is_mounted","text":"Is this a mounted SD card. Returns: Name Type Description mounted bool True if card_root is a mounted filesystem. Raises: Type Description err ( Exception ) on windows is_mount isnpt available Source code in deluge_card/deluge_card.py 110 111 112 113 114 115 116 117 118 119 def is_mounted ( self ) -> bool : \"\"\"Is this a mounted SD card. Returns: mounted (bool): True if card_root is a mounted filesystem. Raises: err (Exception): on windows is_mount isnpt available \"\"\" return Path ( self . card_root ) . is_mount ()","title":"is_mounted()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.kits","text":"Generator for kits in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeKit the next kit on the card. Source code in deluge_card/deluge_card.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def kits ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeKit' ]: \"\"\"Generator for kits in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeKit): the next kit on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , KITS ) . rglob ( '*.XML' )): if not pattern : yield DelugeKit ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeKit ( self , filepath )","title":"kits()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.mv_samples","text":"Move samples, updating any affected XML files. Parameters: Name Type Description Default pattern str glob-style filename pattern. required dest Path (Path): new path for the moved objec(s) required Yields: Name Type Description object ModOp Details of the move operation. Source code in deluge_card/deluge_card.py 190 191 192 193 194 195 196 197 198 199 200 def mv_samples ( self , pattern : str , dest : Path ) -> Iterator [ ModOp ]: \"\"\"Move samples, updating any affected XML files. Args: pattern (str): glob-style filename pattern. dest: (Path): new path for the moved objec(s) Yields: object (ModOp): Details of the move operation. \"\"\" yield from mv_samples ( self . card_root , self . samples ( pattern ), pattern , dest )","title":"mv_samples()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.samples","text":"Generator for all samples in the card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def samples ( self , pattern : str = \"\" ) -> Iterator [ Sample ]: \"\"\"Generator for all samples in the card. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_samples = self . used_samples ( pattern ) all_samples = self . _sample_files ( pattern ) for sample in used_samples : sample_map [ sample . path ] = sample yield sample for sample in all_samples : if sample . path not in sample_map : sample_map [ sample . path ] = sample yield sample","title":"samples()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.songs","text":"Generator for songs in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSong the next song on the card. Source code in deluge_card/deluge_card.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def songs ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSong' ]: \"\"\"Generator for songs in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSong): the next song on the card. \"\"\" for songfile in sorted ( Path ( self . card_root , SONGS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSong ( self , songfile ) # type: ignore continue if PurePath ( songfile ) . match ( pattern ): yield DelugeSong ( self , songfile )","title":"songs()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.synths","text":"Generator for synths in the Card. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object DelugeSynth the next synth on the card. Source code in deluge_card/deluge_card.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def synths ( self , pattern : str = \"\" ) -> Iterator [ 'DelugeSynth' ]: \"\"\"Generator for synths in the Card. Args: pattern (str): glob-style filename pattern. Yields: object (DelugeSynth): the next synth on the card. \"\"\" for filepath in sorted ( Path ( self . card_root , SYNTHS ) . rglob ( '*.XML' )): if not pattern : yield DelugeSynth ( self , filepath ) # type: ignore continue if PurePath ( filepath ) . match ( pattern ): yield DelugeSynth ( self , filepath )","title":"synths()"},{"location":"api/#deluge_card.deluge_card.DelugeCardFS.used_samples","text":"Get all samples referenced in XML files. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample on the card. Source code in deluge_card/deluge_card.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def used_samples ( self , pattern : str = '' ) -> Iterator [ 'Sample' ]: \"\"\"Get all samples referenced in XML files. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample on the card. \"\"\" sample_map : Dict [ Path , Sample ] = dict () used_sample_gens = itertools . chain ( map ( lambda synth : synth . samples ( pattern ), self . synths ()), map ( lambda sng : sng . samples ( pattern ), self . songs ()), map ( lambda kit : kit . samples ( pattern ), self . kits ()), ) # merge samples in different settings (song, kit, synth) for sample in itertools . chain . from_iterable ( used_sample_gens ): if sample . path in sample_map : sample_map [ sample . path ] . settings += sample . settings else : sample_map [ sample . path ] = sample return ( s for s in sample_map . values ())","title":"used_samples()"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard","text":"Bases: Exception This is not a valid DelugeCard FS. Source code in deluge_card/deluge_card.py 48 49 50 51 52 53 54 55 56 57 class InvalidDelugeCard ( Exception ): \"\"\"This is not a valid DelugeCard FS.\"\"\" def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str","title":"InvalidDelugeCard"},{"location":"api/#deluge_card.deluge_card.InvalidDelugeCard.__init__","text":"Create a new InvalidDelugeCard Exception. Attributes: Name Type Description msg str Human readable string describing the exception. Source code in deluge_card/deluge_card.py 51 52 53 54 55 56 57 def __init__ ( self , msg ): \"\"\"Create a new InvalidDelugeCard Exception. Attributes: msg (str): Human readable string describing the exception. \"\"\" msg : str","title":"__init__()"},{"location":"api/#deluge_card.deluge_card.list_deluge_fs","text":"List deluge_card look-alike filesystems. Parameters: Name Type Description Default folder str path of target folder. required Yields: Name Type Description cards Iterator [ DelugeCardFS ] generator of DelugeCardFS instances. Source code in deluge_card/deluge_card.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def list_deluge_fs ( folder ) -> Iterator [ 'DelugeCardFS' ]: \"\"\"List deluge_card look-alike filesystems. Args: folder (str): path of target folder. Yields: cards (Iterator[DelugeCardFS]): generator of DelugeCardFS instances. \"\"\" def _test_card_fs ( folder ): try : return DelugeCardFS . from_folder ( folder ) except InvalidDelugeCard : return card = _test_card_fs ( folder ) if card : yield card for fldr in Path ( folder ) . iterdir (): card = _test_card_fs ( fldr ) if not card : continue yield card","title":"list_deluge_fs()"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 [0.7.0] - 2022-05-24 \u00b6 Changed \u00b6 resolved sample * setting iteration issue. fixed some docstrings. [0.6.1] - 2022-05-19 \u00b6 Changed \u00b6 bad changelog entry for 0.6.0 [0.6.0] - 2022-05-19 \u00b6 Added \u00b6 mv_samples method on DelugeCardFS for top-level API. Changed \u00b6 updated usage to show move example refactored samples listing to deluge_card module [0.5.0] - 2022-05-18 \u00b6 Added \u00b6 handle recursive paths for SONG, KIT, SYNTH folders for firmware 4.0+ mv_samples handles KITS mv_samples handles SYNTHS drop illegal XML elements more test coverage local dev scripts for XML validation and manual tests [0.4.2] - 2022-05-12 \u00b6 Changed \u00b6 fix issue 12 file not found improve reporting [0.4.1] - 2022-05-11 \u00b6 Changed \u00b6 fix path logic and validation; add validation tests; improve test cover make error tests OS independent; [0.4.0] - 2022-05-11 \u00b6 Added \u00b6 new mv_samples method. new validate_mv_dest method. more usage examples. simple scripts/dmv.py script for testing. more typing. new DelugeCardFS.from_folder() static method. list of features in README. Changed \u00b6 using attrs, some methods are now attributes. root_note, scale changes. improving docstrings. [0.3.0] - 2022-05-03 \u00b6 Added \u00b6 Posix glob-style filename matching for songs, samples, song_samples. [0.2.3] - 2022-05-02 \u00b6 Changed \u00b6 Removed dev-requirements from the published package. [0.2.2] - 2022-05-01 \u00b6 Added \u00b6 read song & sample basics deluge filesystem basics [0.1.1-alpha1] - 2022-04-30 \u00b6 Changed \u00b6 tagged release for doc publication [0.1.0] - 2022-04-30 \u00b6 Changed \u00b6 First release on PyPI.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#070---2022-05-24","text":"","title":"[0.7.0] - 2022-05-24"},{"location":"changelog/#changed","text":"resolved sample * setting iteration issue. fixed some docstrings.","title":"Changed"},{"location":"changelog/#061---2022-05-19","text":"","title":"[0.6.1] - 2022-05-19"},{"location":"changelog/#changed_1","text":"bad changelog entry for 0.6.0","title":"Changed"},{"location":"changelog/#060---2022-05-19","text":"","title":"[0.6.0] - 2022-05-19"},{"location":"changelog/#added","text":"mv_samples method on DelugeCardFS for top-level API.","title":"Added"},{"location":"changelog/#changed_2","text":"updated usage to show move example refactored samples listing to deluge_card module","title":"Changed"},{"location":"changelog/#050---2022-05-18","text":"","title":"[0.5.0] - 2022-05-18"},{"location":"changelog/#added_1","text":"handle recursive paths for SONG, KIT, SYNTH folders for firmware 4.0+ mv_samples handles KITS mv_samples handles SYNTHS drop illegal XML elements more test coverage local dev scripts for XML validation and manual tests","title":"Added"},{"location":"changelog/#042---2022-05-12","text":"","title":"[0.4.2] - 2022-05-12"},{"location":"changelog/#changed_3","text":"fix issue 12 file not found improve reporting","title":"Changed"},{"location":"changelog/#041---2022-05-11","text":"","title":"[0.4.1] - 2022-05-11"},{"location":"changelog/#changed_4","text":"fix path logic and validation; add validation tests; improve test cover make error tests OS independent;","title":"Changed"},{"location":"changelog/#040---2022-05-11","text":"","title":"[0.4.0] - 2022-05-11"},{"location":"changelog/#added_2","text":"new mv_samples method. new validate_mv_dest method. more usage examples. simple scripts/dmv.py script for testing. more typing. new DelugeCardFS.from_folder() static method. list of features in README.","title":"Added"},{"location":"changelog/#changed_5","text":"using attrs, some methods are now attributes. root_note, scale changes. improving docstrings.","title":"Changed"},{"location":"changelog/#030---2022-05-03","text":"","title":"[0.3.0] - 2022-05-03"},{"location":"changelog/#added_3","text":"Posix glob-style filename matching for songs, samples, song_samples.","title":"Added"},{"location":"changelog/#023---2022-05-02","text":"","title":"[0.2.3] - 2022-05-02"},{"location":"changelog/#changed_6","text":"Removed dev-requirements from the published package.","title":"Changed"},{"location":"changelog/#022---2022-05-01","text":"","title":"[0.2.2] - 2022-05-01"},{"location":"changelog/#added_4","text":"read song & sample basics deluge filesystem basics","title":"Added"},{"location":"changelog/#011-alpha1---2022-04-30","text":"","title":"[0.1.1-alpha1] - 2022-04-30"},{"location":"changelog/#changed_7","text":"tagged release for doc publication","title":"Changed"},{"location":"changelog/#010---2022-04-30","text":"","title":"[0.1.0] - 2022-04-30"},{"location":"changelog/#changed_8","text":"First release on PyPI.","title":"Changed"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_deluge_card.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/mupaduw/deluge-card/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"deluge-card could always use more documentation, whether as part of the official deluge-card docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/mupaduw/deluge-card/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up deluge-card for local development. Fork the deluge-card repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/deluge-card.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8 and 3.9. Check https://github.com/mupaduw/deluge-card/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_deluge_card.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install deluge-card, run this command in your terminal: $ pip install deluge-card This is the preferred method to install deluge-card, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for deluge-card can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/mupaduw/deluge-card Or download the tarball : $ curl -OJL https://github.com/mupaduw/deluge-card/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"modules/","text":"Modules \u00b6 Module: deluge_sample \u00b6 Main classes representing Deluge Sample. ModOp \u00b6 Bases: object Represents a successful modification operation. Attributes: Name Type Description operation str str path str file path instance Any modified instance. Source code in deluge_card/deluge_sample.py 190 191 192 193 194 195 196 197 198 199 200 201 202 @define class ModOp ( object ): \"\"\"Represents a successful modification operation. Attributes: operation: str path (str): file path instance (Any): modified instance. \"\"\" operation : str path : str instance : object Sample \u00b6 Bases: object represents a sample file. Attributes: Name Type Description path Path Path object for the sample file. settings list [ SampleSetting ] list of SampleSettings for this sample Source code in deluge_card/deluge_sample.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @define # (frozen=True) class Sample ( object ): \"\"\"represents a sample file. Attributes: path (Path): Path object for the sample file. settings (list[SampleSetting]): list of SampleSettings for this sample \"\"\" path : Path settings : List [ 'SampleSetting' ] = field ( factory = list , eq = False ) def __eq__ ( self , other ): return super ( Sample , self ) . __eq__ ( other ) def __hash__ ( self ): return super ( Sample , self ) . __hash__ () SampleMoveOperation \u00b6 Bases: object Represents a sample file move operation. Attributes: Name Type Description old_path Path original Path. new_path Path new Path. sample Sample sample instance. Source code in deluge_card/deluge_sample.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @define ( eq = False ) class SampleMoveOperation ( object ): \"\"\"Represents a sample file move operation. Attributes: old_path (Path): original Path. new_path (Path): new Path. sample (Sample): sample instance. \"\"\" old_path : Path new_path : Path sample : 'Sample' uniqid : int = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( self . old_path ) def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path ) do_move () \u00b6 Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. Source code in deluge_card/deluge_sample.py 146 147 148 149 150 151 152 153 154 def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path ) SampleSetting \u00b6 Bases: object represents a sample in the context of a DelugeXML file. Attributes: Name Type Description xml_file deluge_xml . DelugeXML object for the XML file (song, kit or synth). xml_path str Xmlpath string locating the sample setting within the XML. Source code in deluge_card/deluge_sample.py 176 177 178 179 180 181 182 183 184 185 186 187 @define class SampleSetting ( object ): \"\"\"represents a sample in the context of a DelugeXML file. Attributes: xml_file (deluge_xml.DelugeXML): object for the XML file (song, kit or synth). xml_path (str): Xmlpath string locating the sample setting within the XML. \"\"\" xml_file : 'deluge_xml.DelugeXML' sample : 'Sample' xml_path : str SettingElementUpdater \u00b6 Bases: object Setting updater class. Attributes: Name Type Description root_xml_path str type or root node : /song/, /kit/, or /sound/. Source code in deluge_card/deluge_sample.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @define class SettingElementUpdater ( object ): \"\"\"Setting updater class. Attributes: root_xml_path (str): type or root node : /song/, /kit/, or /sound/. \"\"\" root_xml_path : str def update_settings ( self , move_op : 'SampleMoveOperation' ): \"\"\"Update settings.\"\"\" # print(f\"DEBUG update_song_elements: {sample}\") for setting in move_op . sample . settings : if not setting . xml_path [: len ( self . root_xml_path )] == self . root_xml_path : continue # print(f\"DEBUG update_song_elements setting: {setting}\") setting . xml_file . update_sample_element ( setting . xml_path , move_op . new_path ) yield setting . xml_file update_settings ( move_op ) \u00b6 Update settings. Source code in deluge_card/deluge_sample.py 51 52 53 54 55 56 57 58 59 def update_settings ( self , move_op : 'SampleMoveOperation' ): \"\"\"Update settings.\"\"\" # print(f\"DEBUG update_song_elements: {sample}\") for setting in move_op . sample . settings : if not setting . xml_path [: len ( self . root_xml_path )] == self . root_xml_path : continue # print(f\"DEBUG update_song_elements setting: {setting}\") setting . xml_file . update_sample_element ( setting . xml_path , move_op . new_path ) yield setting . xml_file modify_sample_kits ( move_ops ) \u00b6 Update kit XML elements. Source code in deluge_card/deluge_sample.py 68 69 70 71 def modify_sample_kits ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_kit.DelugeKit' ]: \"\"\"Update kit XML elements.\"\"\" updater = SettingElementUpdater ( '/kit/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops )) modify_sample_paths ( root , samples , pattern , dest ) \u00b6 Modify sample paths just as posix mv does. Source code in deluge_card/deluge_sample.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def modify_sample_paths ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ) -> Iterator [ 'SampleMoveOperation' ]: \"\"\"Modify sample paths just as posix mv does.\"\"\" def glob_match ( sample ) -> bool : return Path ( sample . path ) . match ( pattern ) def build_move_op ( sample ) -> SampleMoveOperation : # print('DEBUG:', sample.path) if dest . suffix == '' : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest , sample . path . name ), sample ) else : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest ), sample ) # sample.path = move_op.new_path.relative_to(root) return move_op matching_samples = filter ( glob_match , samples ) return map ( build_move_op , matching_samples ) modify_sample_songs ( move_ops ) \u00b6 Update song XML elements. Source code in deluge_card/deluge_sample.py 62 63 64 65 def modify_sample_songs ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_song.DelugeSong' ]: \"\"\"Update song XML elements.\"\"\" updater = SettingElementUpdater ( '/song/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops )) modify_sample_synths ( move_ops ) \u00b6 Update synth XML elements. Source code in deluge_card/deluge_sample.py 74 75 76 77 def modify_sample_synths ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_synth.DelugeSynth' ]: \"\"\"Update synth XML elements.\"\"\" updater = SettingElementUpdater ( '/sound/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops )) mv_samples ( root , samples , pattern , dest ) \u00b6 Move samples, updating any affected XML files. Source code in deluge_card/deluge_sample.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def mv_samples ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ): \"\"\"Move samples, updating any affected XML files.\"\"\" dest = ensure_absolute ( root , dest ) validate_mv_dest ( root , dest ) # raises exception if args are invalid sample_move_ops = list ( modify_sample_paths ( root , samples , pattern , dest )) # materialise the list updated_songs = set ( modify_sample_songs ( sample_move_ops )) updated_kits = set ( modify_sample_kits ( sample_move_ops )) updated_synths = set ( modify_sample_synths ( sample_move_ops )) # write the modified XML, per unique song, kit, synth # TODO this is writing files multiple times for updated , tag in [( updated_songs , 'song' ), ( updated_kits , 'kit' ), ( updated_synths , 'synth' )]: for xml in updated : xml . write_xml () yield ModOp ( f \"update_ { tag } _xml\" , str ( xml . path ), xml ) # move the samples for move_op in set ( sample_move_ops ): move_op . do_move () yield ModOp ( \"move_file\" , str ( move_op . new_path ), move_op ) validate_mv_dest ( root , dest ) \u00b6 Source code in deluge_card/deluge_sample.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def validate_mv_dest ( root : Path , dest : Path ): \"\"\"Check: dest path must be a child of root and must exist.\"\"\" absolute_dest = ensure_absolute ( root , dest ) # file as target if absolute_dest . suffix : # looks like a file target if not absolute_dest . parent . exists (): raise ValueError ( f \"target folder does not exist: { dest } \" ) # folder as target elif not ( absolute_dest . is_dir ()): raise ValueError ( f \"target folder does not exist: { dest } \" ) try : absolute_dest . parent . relative_to ( root ) except ValueError : raise ValueError ( \"Destination must be a sub-folder of card.\" ) Module: deluge_song \u00b6 Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js DelugeSong \u00b6 Bases: DelugeXml Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_song.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @define ( repr = False , hash = False , eq = False ) class DelugeSong ( DelugeXml ): \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): # self.samples_xpath = \".//*[@fileName]\" self . root_elem = 'song' super ( DelugeSong , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeSong( { self . path } )\" def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo minimum_firmware () \u00b6 Get the songs earliest Compatible Firmware version. Returns: Name Type Description str str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 61 62 63 64 65 66 67 def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) mode_notes () \u00b6 Get the notes in the song scale (mode). Returns: Type Description List [ int ] [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 77 78 79 80 81 82 83 84 def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] root_note () \u00b6 Get the root note. Returns: Name Type Description int int root note (e.g 36 for C3). Source code in deluge_card/deluge_song.py 69 70 71 72 73 74 75 def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) scale () \u00b6 Get the song scale and key. Returns: Name Type Description str str scale name. Source code in deluge_card/deluge_song.py 98 99 100 101 102 103 104 105 106 def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' scale_mode () \u00b6 Get the descriptive name of the song scale (mode). Returns: Name Type Description str str scale_mode name. Source code in deluge_card/deluge_song.py 86 87 88 89 90 91 92 93 94 95 96 def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' tempo () \u00b6 Get the song tempo in beats per minute. Returns: Name Type Description float float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo Mode \u00b6 Bases: enum . Enum Enum for the scale modes. Source code in deluge_card/deluge_song.py 29 30 31 32 33 34 35 36 37 38 class Mode ( enum . Enum ): \"\"\"Enum for the scale modes.\"\"\" major = [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ] minor = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] dorian = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] phrygian = [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ] lydian = [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ] mixolydian = [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ] locrian = [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ] Module: deluge_kit \u00b6 Main class representing a Deluge Kit. DelugeKit \u00b6 Bases: DelugeXml Class representing kit data on a DelugeCard (in KITS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_kit.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @define ( repr = False , hash = False , eq = False ) class DelugeKit ( DelugeXml ): \"\"\"Class representing kit data on a DelugeCard (in KITS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): # Sself.samples_xpath = \".//fileName\" self . root_elem = 'kit' super ( DelugeKit , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeKit( { self . path } )\" Module: deluge_synth \u00b6 Main class representing a Deluge Synth. DelugeSynth \u00b6 Bases: DelugeXml Class representing a synth template on a DelugeCard (in SYNTHS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_synth.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @define ( repr = False , hash = False , eq = False ) class DelugeSynth ( DelugeXml ): \"\"\"Class representing a synth template on a DelugeCard (in SYNTHS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): self . root_elem = 'sound' super ( DelugeSynth , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeSynth( { self . path } )\" Module: deluge_xml \u00b6 Base class for a Deluge XML file. DelugeXml \u00b6 Class representing XML n a DelugeCard (in SONG|KIT|SYNTH xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_xml.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @define class DelugeXml : \"\"\"Class representing XML n a DelugeCard (in SONG|KIT|SYNTH xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path xmlroot : etree . ElementTree = field ( init = False ) uniqid : int = field ( init = False ) # samples_xpath: str = field(init=False) root_elem : str = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( f ' { str ( self . cardfs . card_root ) }{ str ( self . path ) } ' ) # ultimately we might want to lazy load here .... # see https://stackoverflow.com/questions/55548536/python-attrs-class-attribute-cached-lazy-load try : parser = etree . XMLParser ( recover = True ) self . xmlroot = etree . parse ( read_and_clean_xml ( self . path ), parser ) . getroot () except Exception as err : print ( f 'parsing { self . path } raises.' ) raise err def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def update_sample_element ( self , xml_path , sample_path ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( xml_path . replace ( f '/ { self . root_elem } /' , '//' )) # print('DEBUG old path', elem.get('fileName'), elem) sample_path = sample_path . relative_to ( self . cardfs . card_root ) if elem . tag == 'fileName' : elem . text = str ( sample_path ) else : elem . set ( 'fileName' , str ( sample_path )) return elem def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) def samples ( self , pattern : str = \"\" , allow_missing = False ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeXML file. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) sample_map : Dict [ Path , Sample ] = dict () def update_sample_map ( sample_file , tree ) -> None : sample = Sample ( ensure_absolute ( self . cardfs . card_root , Path ( sample_file ))) if sample . path in sample_map . keys (): sample = sample_map [ sample . path ] else : sample_map [ sample . path ] = sample sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) def match_pattern ( sample_file : str , pattern : str ) -> None : if sample_file : if ( not allow_missing ) and ( not ensure_absolute ( self . cardfs . card_root , Path ( sample_file )) . exists ()): return if not pattern : update_sample_map ( sample_file , tree ) elif PurePath ( sample_file ) . match ( pattern ): update_sample_map ( sample_file , tree ) for e in self . xmlroot . findall ( \".//*[@fileName]\" ): match_pattern ( e . get ( 'fileName' ), pattern ) for e in self . xmlroot . findall ( \".//fileName\" ): match_pattern ( e . text , pattern ) return ( m for m in sample_map . values ()) samples ( pattern = '' , allow_missing = False ) \u00b6 Generator for samples referenced in the DelugeXML file. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_xml.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def samples ( self , pattern : str = \"\" , allow_missing = False ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeXML file. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) sample_map : Dict [ Path , Sample ] = dict () def update_sample_map ( sample_file , tree ) -> None : sample = Sample ( ensure_absolute ( self . cardfs . card_root , Path ( sample_file ))) if sample . path in sample_map . keys (): sample = sample_map [ sample . path ] else : sample_map [ sample . path ] = sample sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) def match_pattern ( sample_file : str , pattern : str ) -> None : if sample_file : if ( not allow_missing ) and ( not ensure_absolute ( self . cardfs . card_root , Path ( sample_file )) . exists ()): return if not pattern : update_sample_map ( sample_file , tree ) elif PurePath ( sample_file ) . match ( pattern ): update_sample_map ( sample_file , tree ) for e in self . xmlroot . findall ( \".//*[@fileName]\" ): match_pattern ( e . get ( 'fileName' ), pattern ) for e in self . xmlroot . findall ( \".//fileName\" ): match_pattern ( e . text , pattern ) return ( m for m in sample_map . values ()) update_sample_element ( xml_path , sample_path ) \u00b6 Update XML element from sample_setting. Source code in deluge_card/deluge_xml.py 68 69 70 71 72 73 74 75 76 77 78 def update_sample_element ( self , xml_path , sample_path ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( xml_path . replace ( f '/ { self . root_elem } /' , '//' )) # print('DEBUG old path', elem.get('fileName'), elem) sample_path = sample_path . relative_to ( self . cardfs . card_root ) if elem . tag == 'fileName' : elem . text = str ( sample_path ) else : elem . set ( 'fileName' , str ( sample_path )) return elem write_xml ( new_path = None ) \u00b6 Write the song XML. Source code in deluge_card/deluge_xml.py 80 81 82 83 84 85 def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) read_and_clean_xml ( xml_path ) \u00b6 Strip illegal elements. Source code in deluge_card/deluge_xml.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def read_and_clean_xml ( xml_path ): \"\"\"Strip illegal elements.\"\"\" newxml = io . BytesIO () with open ( xml_path , 'rb' ) as f : lcount = 0 for line in f . readlines (): lcount += 1 if b '<firmwareVersion>' == line [: 17 ] and lcount < 3 : continue if b '<earliestCompatibleFirmware>' == line [: 28 ] and lcount < 4 : continue newxml . write ( line ) newxml . seek ( 0 ) return newxml","title":"Modules"},{"location":"modules/#modules","text":"","title":"Modules"},{"location":"modules/#module-deluge_sample","text":"Main classes representing Deluge Sample.","title":"Module: deluge_sample"},{"location":"modules/#deluge_card.deluge_sample.ModOp","text":"Bases: object Represents a successful modification operation. Attributes: Name Type Description operation str str path str file path instance Any modified instance. Source code in deluge_card/deluge_sample.py 190 191 192 193 194 195 196 197 198 199 200 201 202 @define class ModOp ( object ): \"\"\"Represents a successful modification operation. Attributes: operation: str path (str): file path instance (Any): modified instance. \"\"\" operation : str path : str instance : object","title":"ModOp"},{"location":"modules/#deluge_card.deluge_sample.Sample","text":"Bases: object represents a sample file. Attributes: Name Type Description path Path Path object for the sample file. settings list [ SampleSetting ] list of SampleSettings for this sample Source code in deluge_card/deluge_sample.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @define # (frozen=True) class Sample ( object ): \"\"\"represents a sample file. Attributes: path (Path): Path object for the sample file. settings (list[SampleSetting]): list of SampleSettings for this sample \"\"\" path : Path settings : List [ 'SampleSetting' ] = field ( factory = list , eq = False ) def __eq__ ( self , other ): return super ( Sample , self ) . __eq__ ( other ) def __hash__ ( self ): return super ( Sample , self ) . __hash__ ()","title":"Sample"},{"location":"modules/#deluge_card.deluge_sample.SampleMoveOperation","text":"Bases: object Represents a sample file move operation. Attributes: Name Type Description old_path Path original Path. new_path Path new Path. sample Sample sample instance. Source code in deluge_card/deluge_sample.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 @define ( eq = False ) class SampleMoveOperation ( object ): \"\"\"Represents a sample file move operation. Attributes: old_path (Path): original Path. new_path (Path): new Path. sample (Sample): sample instance. \"\"\" old_path : Path new_path : Path sample : 'Sample' uniqid : int = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( self . old_path ) def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path )","title":"SampleMoveOperation"},{"location":"modules/#deluge_card.deluge_sample.SampleMoveOperation.do_move","text":"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. Source code in deluge_card/deluge_sample.py 146 147 148 149 150 151 152 153 154 def do_move ( self ): \"\"\"Complete the move operation. We expect the destination path to exist (much like regular mv) as this helps the end user avoid mistakes. \"\"\" # if not self.new_path.parent.exists(): # self.new_path.parent.mkdir(exist_ok=True, parents=True) self . old_path . rename ( self . new_path )","title":"do_move()"},{"location":"modules/#deluge_card.deluge_sample.SampleSetting","text":"Bases: object represents a sample in the context of a DelugeXML file. Attributes: Name Type Description xml_file deluge_xml . DelugeXML object for the XML file (song, kit or synth). xml_path str Xmlpath string locating the sample setting within the XML. Source code in deluge_card/deluge_sample.py 176 177 178 179 180 181 182 183 184 185 186 187 @define class SampleSetting ( object ): \"\"\"represents a sample in the context of a DelugeXML file. Attributes: xml_file (deluge_xml.DelugeXML): object for the XML file (song, kit or synth). xml_path (str): Xmlpath string locating the sample setting within the XML. \"\"\" xml_file : 'deluge_xml.DelugeXML' sample : 'Sample' xml_path : str","title":"SampleSetting"},{"location":"modules/#deluge_card.deluge_sample.SettingElementUpdater","text":"Bases: object Setting updater class. Attributes: Name Type Description root_xml_path str type or root node : /song/, /kit/, or /sound/. Source code in deluge_card/deluge_sample.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @define class SettingElementUpdater ( object ): \"\"\"Setting updater class. Attributes: root_xml_path (str): type or root node : /song/, /kit/, or /sound/. \"\"\" root_xml_path : str def update_settings ( self , move_op : 'SampleMoveOperation' ): \"\"\"Update settings.\"\"\" # print(f\"DEBUG update_song_elements: {sample}\") for setting in move_op . sample . settings : if not setting . xml_path [: len ( self . root_xml_path )] == self . root_xml_path : continue # print(f\"DEBUG update_song_elements setting: {setting}\") setting . xml_file . update_sample_element ( setting . xml_path , move_op . new_path ) yield setting . xml_file","title":"SettingElementUpdater"},{"location":"modules/#deluge_card.deluge_sample.SettingElementUpdater.update_settings","text":"Update settings. Source code in deluge_card/deluge_sample.py 51 52 53 54 55 56 57 58 59 def update_settings ( self , move_op : 'SampleMoveOperation' ): \"\"\"Update settings.\"\"\" # print(f\"DEBUG update_song_elements: {sample}\") for setting in move_op . sample . settings : if not setting . xml_path [: len ( self . root_xml_path )] == self . root_xml_path : continue # print(f\"DEBUG update_song_elements setting: {setting}\") setting . xml_file . update_sample_element ( setting . xml_path , move_op . new_path ) yield setting . xml_file","title":"update_settings()"},{"location":"modules/#deluge_card.deluge_sample.modify_sample_kits","text":"Update kit XML elements. Source code in deluge_card/deluge_sample.py 68 69 70 71 def modify_sample_kits ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_kit.DelugeKit' ]: \"\"\"Update kit XML elements.\"\"\" updater = SettingElementUpdater ( '/kit/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops ))","title":"modify_sample_kits()"},{"location":"modules/#deluge_card.deluge_sample.modify_sample_paths","text":"Modify sample paths just as posix mv does. Source code in deluge_card/deluge_sample.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def modify_sample_paths ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ) -> Iterator [ 'SampleMoveOperation' ]: \"\"\"Modify sample paths just as posix mv does.\"\"\" def glob_match ( sample ) -> bool : return Path ( sample . path ) . match ( pattern ) def build_move_op ( sample ) -> SampleMoveOperation : # print('DEBUG:', sample.path) if dest . suffix == '' : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest , sample . path . name ), sample ) else : move_op = SampleMoveOperation ( ensure_absolute ( root , sample . path ), Path ( dest ), sample ) # sample.path = move_op.new_path.relative_to(root) return move_op matching_samples = filter ( glob_match , samples ) return map ( build_move_op , matching_samples )","title":"modify_sample_paths()"},{"location":"modules/#deluge_card.deluge_sample.modify_sample_songs","text":"Update song XML elements. Source code in deluge_card/deluge_sample.py 62 63 64 65 def modify_sample_songs ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_song.DelugeSong' ]: \"\"\"Update song XML elements.\"\"\" updater = SettingElementUpdater ( '/song/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops ))","title":"modify_sample_songs()"},{"location":"modules/#deluge_card.deluge_sample.modify_sample_synths","text":"Update synth XML elements. Source code in deluge_card/deluge_sample.py 74 75 76 77 def modify_sample_synths ( move_ops : List [ 'SampleMoveOperation' ]) -> Iterator [ 'deluge_synth.DelugeSynth' ]: \"\"\"Update synth XML elements.\"\"\" updater = SettingElementUpdater ( '/sound/' ) return itertools . chain . from_iterable ( map ( updater . update_settings , move_ops ))","title":"modify_sample_synths()"},{"location":"modules/#deluge_card.deluge_sample.mv_samples","text":"Move samples, updating any affected XML files. Source code in deluge_card/deluge_sample.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 def mv_samples ( root : Path , samples : Iterator [ 'Sample' ], pattern : str , dest : Path ): \"\"\"Move samples, updating any affected XML files.\"\"\" dest = ensure_absolute ( root , dest ) validate_mv_dest ( root , dest ) # raises exception if args are invalid sample_move_ops = list ( modify_sample_paths ( root , samples , pattern , dest )) # materialise the list updated_songs = set ( modify_sample_songs ( sample_move_ops )) updated_kits = set ( modify_sample_kits ( sample_move_ops )) updated_synths = set ( modify_sample_synths ( sample_move_ops )) # write the modified XML, per unique song, kit, synth # TODO this is writing files multiple times for updated , tag in [( updated_songs , 'song' ), ( updated_kits , 'kit' ), ( updated_synths , 'synth' )]: for xml in updated : xml . write_xml () yield ModOp ( f \"update_ { tag } _xml\" , str ( xml . path ), xml ) # move the samples for move_op in set ( sample_move_ops ): move_op . do_move () yield ModOp ( \"move_file\" , str ( move_op . new_path ), move_op )","title":"mv_samples()"},{"location":"modules/#deluge_card.deluge_sample.validate_mv_dest","text":"Source code in deluge_card/deluge_sample.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def validate_mv_dest ( root : Path , dest : Path ): \"\"\"Check: dest path must be a child of root and must exist.\"\"\" absolute_dest = ensure_absolute ( root , dest ) # file as target if absolute_dest . suffix : # looks like a file target if not absolute_dest . parent . exists (): raise ValueError ( f \"target folder does not exist: { dest } \" ) # folder as target elif not ( absolute_dest . is_dir ()): raise ValueError ( f \"target folder does not exist: { dest } \" ) try : absolute_dest . parent . relative_to ( root ) except ValueError : raise ValueError ( \"Destination must be a sub-folder of card.\" )","title":"validate_mv_dest()"},{"location":"modules/#module-deluge_song","text":"Main classes representing a Deluge Song. Credit & thanks to Jamie Faye ref https://github.com/jamiefaye/downrush/blob/master/xmlView/src/SongUtils.js","title":"Module: deluge_song"},{"location":"modules/#deluge_card.deluge_song.DelugeSong","text":"Bases: DelugeXml Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_song.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @define ( repr = False , hash = False , eq = False ) class DelugeSong ( DelugeXml ): \"\"\"Class representing song data on a DelugeCard (in SONGS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): # self.samples_xpath = \".//*[@fileName]\" self . root_elem = 'song' super ( DelugeSong , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeSong( { self . path } )\" def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' ) def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' )) def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ] def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other' def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } ' def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo","title":"DelugeSong"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.minimum_firmware","text":"Get the songs earliest Compatible Firmware version. Returns: Name Type Description str str earliestCompatibleFirmware version. Source code in deluge_card/deluge_song.py 61 62 63 64 65 66 67 def minimum_firmware ( self ) -> str : \"\"\"Get the songs earliest Compatible Firmware version. Returns: str: earliestCompatibleFirmware version. \"\"\" return self . xmlroot . get ( 'earliestCompatibleFirmware' )","title":"minimum_firmware()"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.mode_notes","text":"Get the notes in the song scale (mode). Returns: Type Description List [ int ] [int]: list of mode intervals, relative to root. Source code in deluge_card/deluge_song.py 77 78 79 80 81 82 83 84 def mode_notes ( self ) -> List [ int ]: \"\"\"Get the notes in the song scale (mode). Returns: [int]: list of mode intervals, relative to root. \"\"\" notes = self . xmlroot . findall ( './/modeNotes/modeNote' ) return [ int ( e . text ) for e in notes ]","title":"mode_notes()"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.root_note","text":"Get the root note. Returns: Name Type Description int int root note (e.g 36 for C3). Source code in deluge_card/deluge_song.py 69 70 71 72 73 74 75 def root_note ( self ) -> int : \"\"\"Get the root note. Returns: int: root note (e.g 36 for C3). \"\"\" return int ( self . xmlroot . get ( 'rootNote' ))","title":"root_note()"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.scale","text":"Get the song scale and key. Returns: Name Type Description str str scale name. Source code in deluge_card/deluge_song.py 98 99 100 101 102 103 104 105 106 def scale ( self ) -> str : \"\"\"Get the song scale and key. Returns: str: scale name. \"\"\" mode = self . scale_mode () root_note = self . root_note () % 12 return f ' { SCALE [ root_note ] } { mode } '","title":"scale()"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.scale_mode","text":"Get the descriptive name of the song scale (mode). Returns: Name Type Description str str scale_mode name. Source code in deluge_card/deluge_song.py 86 87 88 89 90 91 92 93 94 95 96 def scale_mode ( self ) -> str : \"\"\"Get the descriptive name of the song scale (mode). Returns: str: scale_mode name. \"\"\" mn = self . mode_notes () try : return Mode ( mn ) . name except ValueError : return 'other'","title":"scale_mode()"},{"location":"modules/#deluge_card.deluge_song.DelugeSong.tempo","text":"Get the song tempo in beats per minute. Returns: Name Type Description float float tempo BPM. Javascript downrush convertTempo() Source code in deluge_card/deluge_song.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def tempo ( self ) -> float : \"\"\"Get the song tempo in beats per minute. Returns: float: tempo BPM. Javascript: [downrush convertTempo()](https://github.com/jamiefaye/downrush/blob /a4fa2794002cdcebb093848af501ca17a32abe9a/xmlView/src/SongViewLib.js#L508) \"\"\" # // Return song tempo calculated from timePerTimerTick and timerTickFraction # function convertTempo(jsong) # { # let fractPart = (jsong.timerTickFraction>>>0) / 0x100000000; # let realTPT = Number(jsong.timePerTimerTick) + fractPart; # // Timer tick math: 44100 = standard Fs; 48 = PPQN; # // tempo = (44100 * 60) / 48 * realTPT; # // tempo = 55125 / realTPT # // rounded to 1 place after decimal point: # let tempo = Math.round(551250 / realTPT) / 10; # # // console.log(\"timePerTimerTick=\" + jsong.timePerTimerTick + \" realTPT= \" + realTPT + # // \" tempo= \" + tempo); # // console.log(\"timerTickFraction=\" + jsong.timerTickFraction + \" fractPart= \" + fractPart); # return tempo; # } fractPart = ( int ( self . xmlroot . get ( 'timerTickFraction' ))) / int ( '0x100000000' , 16 ) # print(int('0x100000000', 16)) # print(fractPart) realTPT = float ( self . xmlroot . get ( 'timePerTimerTick' )) + fractPart # print(realTPT) tempo = round (( 44100 * 60 ) / ( 96 * realTPT ), 1 ) # tempo = round(55125/realTPT/2, 1) return tempo","title":"tempo()"},{"location":"modules/#deluge_card.deluge_song.Mode","text":"Bases: enum . Enum Enum for the scale modes. Source code in deluge_card/deluge_song.py 29 30 31 32 33 34 35 36 37 38 class Mode ( enum . Enum ): \"\"\"Enum for the scale modes.\"\"\" major = [ 0 , 2 , 4 , 5 , 7 , 9 , 11 ] minor = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] dorian = [ 0 , 2 , 3 , 5 , 7 , 9 , 10 ] phrygian = [ 0 , 1 , 3 , 5 , 7 , 8 , 10 ] lydian = [ 0 , 2 , 4 , 6 , 7 , 9 , 11 ] mixolydian = [ 0 , 2 , 4 , 5 , 7 , 9 , 10 ] locrian = [ 0 , 1 , 3 , 5 , 6 , 8 , 10 ]","title":"Mode"},{"location":"modules/#module-deluge_kit","text":"Main class representing a Deluge Kit.","title":"Module: deluge_kit"},{"location":"modules/#deluge_card.deluge_kit.DelugeKit","text":"Bases: DelugeXml Class representing kit data on a DelugeCard (in KITS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_kit.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @define ( repr = False , hash = False , eq = False ) class DelugeKit ( DelugeXml ): \"\"\"Class representing kit data on a DelugeCard (in KITS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): # Sself.samples_xpath = \".//fileName\" self . root_elem = 'kit' super ( DelugeKit , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeKit( { self . path } )\"","title":"DelugeKit"},{"location":"modules/#module-deluge_synth","text":"Main class representing a Deluge Synth.","title":"Module: deluge_synth"},{"location":"modules/#deluge_card.deluge_synth.DelugeSynth","text":"Bases: DelugeXml Class representing a synth template on a DelugeCard (in SYNTHS/*.xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_synth.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @define ( repr = False , hash = False , eq = False ) class DelugeSynth ( DelugeXml ): \"\"\"Class representing a synth template on a DelugeCard (in SYNTHS/*.xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path def __attrs_post_init__ ( self ): self . root_elem = 'sound' super ( DelugeSynth , self ) . __attrs_post_init__ () def __repr__ ( self ) -> str : return f \"DelugeSynth( { self . path } )\"","title":"DelugeSynth"},{"location":"modules/#module-deluge_xml","text":"Base class for a Deluge XML file.","title":"Module: deluge_xml"},{"location":"modules/#deluge_card.deluge_xml.DelugeXml","text":"Class representing XML n a DelugeCard (in SONG|KIT|SYNTH xml). Attributes: Name Type Description cardfs DelugeCardFS Card folder system containing this file. path Path Path object for the sample file. file. Source code in deluge_card/deluge_xml.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 @define class DelugeXml : \"\"\"Class representing XML n a DelugeCard (in SONG|KIT|SYNTH xml). Attributes: cardfs (DelugeCardFS): Card folder system containing this file. path (Path): Path object for the sample file. file. \"\"\" cardfs : 'DelugeCardFS' path : Path xmlroot : etree . ElementTree = field ( init = False ) uniqid : int = field ( init = False ) # samples_xpath: str = field(init=False) root_elem : str = field ( init = False ) def __attrs_post_init__ ( self ): self . uniqid = hash ( f ' { str ( self . cardfs . card_root ) }{ str ( self . path ) } ' ) # ultimately we might want to lazy load here .... # see https://stackoverflow.com/questions/55548536/python-attrs-class-attribute-cached-lazy-load try : parser = etree . XMLParser ( recover = True ) self . xmlroot = etree . parse ( read_and_clean_xml ( self . path ), parser ) . getroot () except Exception as err : print ( f 'parsing { self . path } raises.' ) raise err def __eq__ ( self , other ): return self . uniqid == other . uniqid def __hash__ ( self ): return self . uniqid def update_sample_element ( self , xml_path , sample_path ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( xml_path . replace ( f '/ { self . root_elem } /' , '//' )) # print('DEBUG old path', elem.get('fileName'), elem) sample_path = sample_path . relative_to ( self . cardfs . card_root ) if elem . tag == 'fileName' : elem . text = str ( sample_path ) else : elem . set ( 'fileName' , str ( sample_path )) return elem def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename ) def samples ( self , pattern : str = \"\" , allow_missing = False ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeXML file. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) sample_map : Dict [ Path , Sample ] = dict () def update_sample_map ( sample_file , tree ) -> None : sample = Sample ( ensure_absolute ( self . cardfs . card_root , Path ( sample_file ))) if sample . path in sample_map . keys (): sample = sample_map [ sample . path ] else : sample_map [ sample . path ] = sample sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) def match_pattern ( sample_file : str , pattern : str ) -> None : if sample_file : if ( not allow_missing ) and ( not ensure_absolute ( self . cardfs . card_root , Path ( sample_file )) . exists ()): return if not pattern : update_sample_map ( sample_file , tree ) elif PurePath ( sample_file ) . match ( pattern ): update_sample_map ( sample_file , tree ) for e in self . xmlroot . findall ( \".//*[@fileName]\" ): match_pattern ( e . get ( 'fileName' ), pattern ) for e in self . xmlroot . findall ( \".//fileName\" ): match_pattern ( e . text , pattern ) return ( m for m in sample_map . values ())","title":"DelugeXml"},{"location":"modules/#deluge_card.deluge_xml.DelugeXml.samples","text":"Generator for samples referenced in the DelugeXML file. Parameters: Name Type Description Default pattern str glob-style filename pattern. '' Yields: Name Type Description object Sample the next sample object. Source code in deluge_card/deluge_xml.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def samples ( self , pattern : str = \"\" , allow_missing = False ) -> Iterator [ Sample ]: \"\"\"Generator for samples referenced in the DelugeXML file. Args: pattern (str): glob-style filename pattern. Yields: object (Sample): the next sample object. \"\"\" tree = etree . ElementTree ( self . xmlroot ) sample_map : Dict [ Path , Sample ] = dict () def update_sample_map ( sample_file , tree ) -> None : sample = Sample ( ensure_absolute ( self . cardfs . card_root , Path ( sample_file ))) if sample . path in sample_map . keys (): sample = sample_map [ sample . path ] else : sample_map [ sample . path ] = sample sample . settings . append ( SampleSetting ( self , sample , tree . getpath ( e ))) def match_pattern ( sample_file : str , pattern : str ) -> None : if sample_file : if ( not allow_missing ) and ( not ensure_absolute ( self . cardfs . card_root , Path ( sample_file )) . exists ()): return if not pattern : update_sample_map ( sample_file , tree ) elif PurePath ( sample_file ) . match ( pattern ): update_sample_map ( sample_file , tree ) for e in self . xmlroot . findall ( \".//*[@fileName]\" ): match_pattern ( e . get ( 'fileName' ), pattern ) for e in self . xmlroot . findall ( \".//fileName\" ): match_pattern ( e . text , pattern ) return ( m for m in sample_map . values ())","title":"samples()"},{"location":"modules/#deluge_card.deluge_xml.DelugeXml.update_sample_element","text":"Update XML element from sample_setting. Source code in deluge_card/deluge_xml.py 68 69 70 71 72 73 74 75 76 77 78 def update_sample_element ( self , xml_path , sample_path ): \"\"\"Update XML element from sample_setting.\"\"\" tree = etree . ElementTree ( self . xmlroot ) elem = tree . find ( xml_path . replace ( f '/ { self . root_elem } /' , '//' )) # print('DEBUG old path', elem.get('fileName'), elem) sample_path = sample_path . relative_to ( self . cardfs . card_root ) if elem . tag == 'fileName' : elem . text = str ( sample_path ) else : elem . set ( 'fileName' , str ( sample_path )) return elem","title":"update_sample_element()"},{"location":"modules/#deluge_card.deluge_xml.DelugeXml.write_xml","text":"Write the song XML. Source code in deluge_card/deluge_xml.py 80 81 82 83 84 85 def write_xml ( self , new_path = None ) -> str : \"\"\"Write the song XML.\"\"\" filename = new_path or self . path with open ( filename , 'wb' ) as doc : doc . write ( etree . tostring ( self . xmlroot , pretty_print = True )) return str ( filename )","title":"write_xml()"},{"location":"modules/#deluge_card.deluge_xml.read_and_clean_xml","text":"Strip illegal elements. Source code in deluge_card/deluge_xml.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def read_and_clean_xml ( xml_path ): \"\"\"Strip illegal elements.\"\"\" newxml = io . BytesIO () with open ( xml_path , 'rb' ) as f : lcount = 0 for line in f . readlines (): lcount += 1 if b '<firmwareVersion>' == line [: 17 ] and lcount < 3 : continue if b '<earliestCompatibleFirmware>' == line [: 28 ] and lcount < 4 : continue newxml . write ( line ) newxml . seek ( 0 ) return newxml","title":"read_and_clean_xml()"},{"location":"usage/","text":"Usage \u00b6 To use deluge-card in a project import deluge_card list cards and their songs: \u00b6 from deluge_card import list_deluge_fs for card in list_deluge_fs('/deluge_cards/root_folder'): print(f'card at {card.path}'') # list the songs on the card for song in card.songs(): print(song, song.tempo(), song.key()) list samples and usage: \u00b6 from deluge_card import DelugeCardFS card = DelugeCardFS('path/to/my/card') # list the samples on the card for samples in card.samples(): usage = list(sample.settings) print(sample, \"used in\", len(usage), \"settings\") move samples \u00b6 card = DelugeCardFS('path/to/my/card') for update_operation in card.mv_samples(\"**/Kick*.wav\", Path('SAMPLES/Moved')): print(update_operation)","title":"Usage"},{"location":"usage/#usage","text":"To use deluge-card in a project import deluge_card","title":"Usage"},{"location":"usage/#list-cards-and-their-songs","text":"from deluge_card import list_deluge_fs for card in list_deluge_fs('/deluge_cards/root_folder'): print(f'card at {card.path}'') # list the songs on the card for song in card.songs(): print(song, song.tempo(), song.key())","title":"list cards and their songs:"},{"location":"usage/#list-samples-and-usage","text":"from deluge_card import DelugeCardFS card = DelugeCardFS('path/to/my/card') # list the samples on the card for samples in card.samples(): usage = list(sample.settings) print(sample, \"used in\", len(usage), \"settings\")","title":"list samples and usage:"},{"location":"usage/#move-samples","text":"card = DelugeCardFS('path/to/my/card') for update_operation in card.mv_samples(\"**/Kick*.wav\", Path('SAMPLES/Moved')): print(update_operation)","title":"move samples"}]}